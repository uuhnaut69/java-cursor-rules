<?xml version="1.0" encoding="UTF-8"?>
<prompt xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="pml.xsd"
    id="121-java-object-oriented-design" version="1.0">

    <metadata>
        <!-- Cursor AI specific configuration -->
        <cursor-ai>
            <description></description>
            <globs></globs>
            <always-apply>false</always-apply>
        </cursor-ai>
        <tags>
            <tag>java</tag>
            <tag>object-oriented</tag>
            <tag>design</tag>
            <tag>best-practices</tag>
        </tags>
        <version>0.8.0</version>
        <title>Java Object-Oriented Design Guidelines</title>
    </metadata>

    <role>You are a Senior software engineer with extensive experience in Java software development</role>

    <goal>
        Apply comprehensive guidelines for robust Java object-oriented design and refactoring. Follow core principles like SOLID, DRY, and YAGNI, implement best practices for class and interface design including favoring composition over inheritance and designing for immutability. Master encapsulation, inheritance, and polymorphism, and identify and refactor common object-oriented design code smells such as God Classes, Feature Envy, and Data Clumps to promote maintainable, flexible, and understandable code.

        ### Implementing These Principles

        These guidelines are built upon the following core principles:

        1.  **Adherence to Fundamental Design Principles**: Embrace foundational principles like SOLID, DRY, and YAGNI. These principles are key to building systems that are robust, maintainable, flexible, and easy to understand.
        2.  **Effective Class and Interface Design**: Employ best practices for designing classes and interfaces. This includes favoring composition over inheritance to achieve flexibility, programming to an interface rather than an implementation to promote loose coupling, keeping classes small and focused on a single responsibility, and designing for immutability where appropriate to enhance simplicity and thread-safety.
        3.  **Mastery of Core OOP Concepts**: Thoroughly understand and correctly apply the pillars of object-oriented programming:
            *   **Encapsulation**: Protect internal state and expose behavior through well-defined interfaces.
            *   **Inheritance**: Model true "is-a" relationships, ensuring subclasses are substitutable for their base types (Liskov Substitution Principle).
            *   **Polymorphism**: Allow objects of different types to respond to the same message in their own way, simplifying client code.
        4.  **Proactive Code Smell Management**: Develop the ability to identify common object-oriented design "code smells" (e.g., God Class, Feature Envy, Data Clumps, Refused Bequest). Recognizing and refactoring these smells is crucial for improving the long-term health, maintainability, and clarity of the codebase.
    </goal>

    <examples>
        <toc auto-generate="true" />

        <example number="1" id="apply-fundamental-software-design-principles">
            <example-header>
                <example-title>Apply Fundamental Software Design Principles</example-title>
                <example-subtitle>Apply Fundamental Software Design Principles</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Core principles like SOLID, DRY, and YAGNI are foundational to good object-oriented design, leading to more robust, maintainable, and understandable systems.
                ]]>
            </example-description>
        </example>

        <example number="2" id="single-responsibility-principle">
            <example-header>
                <example-title>Single Responsibility Principle (SRP)</example-title>
                <example-subtitle>A class should have one, and only one, reason to change.</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                This means a class should only have one job or primary responsibility. If a class handles multiple responsibilities, changes to one responsibility might inadvertently affect others.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// Good: Separate responsibilities
class UserData {
    private String name;
    private String email;
    // constructor, getters
    public UserData(String name, String email) { this.name = name; this.email = email; }
    public String getName() { return name; }
    public String getEmail() { return email; }
}

class UserPersistence {
    public void saveUser(UserData user) {
        System.out.println("Saving user " + user.getName() + " to database.");
        // Database saving logic
    }
}

class UserEmailer {
    public void sendWelcomeEmail(UserData user) {
        System.out.println("Sending welcome email to " + user.getEmail());
        // Email sending logic
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Bad: User class with multiple responsibilities
class User {
    private String name;
    private String email;

    public User(String name, String email) { this.name = name; this.email = email; }

    public String getName() { return name; }
    public String getEmail() { return email; }

    public void saveToDatabase() {
        System.out.println("Saving user " + name + " to database.");
        // Database logic mixed in
    }

    public void sendWelcomeEmail() {
        System.out.println("Sending welcome email to " + email);
        // Email logic mixed in
    }
    // If email sending changes, or DB logic changes, this class needs to change.
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="3" id="open-closed-principle">
            <example-header>
                <example-title>Open/Closed Principle (OCP)</example-title>
                <example-subtitle>Software entities should be open for extension but closed for modification.</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                You should be able to add new functionality without changing existing, tested code. This is often achieved using interfaces, abstract classes, and polymorphism.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[interface Shape {
    double calculateArea();
}

class Rectangle implements Shape {
    private double width, height;
    public Rectangle(double w, double h) { width=w; height=h; }
    @Override public double calculateArea() { return width * height; }
}

class Circle implements Shape {
    private double radius;
    public Circle(double r) { radius=r; }
    @Override public double calculateArea() { return Math.PI * radius * radius; }
}

// New shapes (e.g., Triangle) can be added by implementing Shape
// without modifying existing Shape, Rectangle, Circle, or AreaCalculator.
class AreaCalculator {
    public double getTotalArea(List<Shape> shapes) {
        return shapes.stream().mapToDouble(Shape::calculateArea).sum();
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Bad: AreaCalculator needs modification for new shapes
class AreaCalculatorBad {
    public double calculateRectangleArea(Rectangle rect) { return rect.width * rect.height; }
    public double calculateCircleArea(Circle circ) { return Math.PI * circ.radius * circ.radius; }
    // If a Triangle class is added, this class must be modified to add calculateTriangleArea().
}
class Rectangle { public double width, height; /* ... */ }
class Circle { public double radius; /* ... */ }]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="4" id="liskov-substitution-principle">
            <example-header>
                <example-title>Liskov Substitution Principle (LSP)</example-title>
                <example-subtitle>Subtypes must be substitutable for their base types.</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Objects of a superclass should be replaceable with objects of its subclasses without affecting the correctness of the program or causing unexpected behavior.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[interface Bird {
    void move();
}

class FlyingBird implements Bird {
    public void fly() { System.out.println("Flying high!"); }
    @Override public void move() { fly(); }
}

class Sparrow extends FlyingBird { /* Can fly */ }

class Ostrich implements Bird { // Ostrich is a Bird but doesn't fly in the typical sense
    public void runFast() { System.out.println("Running fast on the ground!"); }
    @Override public void move() { runFast(); }
}

public class BirdLSPExample {
    public static void makeBirdMove(Bird bird) {
        bird.move(); // Works correctly for Sparrow (flies) and Ostrich (runs)
    }
    public static void main(String args) {
        makeBirdMove(new Sparrow());
        makeBirdMove(new Ostrich());
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Bad: Violating LSP
class Bird {
    public void fly() { System.out.println("Bird is flying."); }
}

class Penguin extends Bird {
    @Override
    public void fly() {
        // Penguins can't fly, so this method might do nothing or throw an exception.
        // This violates LSP because a Penguin can't simply replace a generic Bird where fly() is expected.
        throw new UnsupportedOperationException("Penguins can't fly.");
    }
    public void swim() { System.out.println("Penguin is swimming."); }
}

public class BirdLSPViolation {
    public static void letTheBirdFly(Bird bird) {
        bird.fly(); // This will crash if bird is a Penguin
    }
    public static void main(String args) {
        try {
            letTheBirdFly(new Penguin());
        } catch (UnsupportedOperationException e) {
            System.err.println(e.getMessage());
        }
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="5" id="interface-segregation-principle">
            <example-header>
                <example-title>Interface Segregation Principle (ISP)</example-title>
                <example-subtitle>Clients should not be forced to depend on interfaces they do not use.</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                It's better to have many small, specific interfaces (role interfaces) than one large, general-purpose interface. This prevents classes from having to implement methods they don't need.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// Good: Segregated interfaces
interface Worker {
    void work();
}

interface Eater {
    void eat();
}

class HumanWorker implements Worker, Eater {
    @Override public void work() { System.out.println("Human working."); }
    @Override public void eat() { System.out.println("Human eating."); }
}

class RobotWorker implements Worker {
    @Override public void work() { System.out.println("Robot working efficiently."); }
    // RobotWorker does not need to implement eat()
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Bad: Fat interface
interface IWorkerAndEater {
    void work();
    void eat(); // All implementers must provide eat(), even if they don't eat.
}

class Human implements IWorkerAndEater {
    @Override public void work() { /* ... */ }
    @Override public void eat() { /* ... */ }
}

class Robot implements IWorkerAndEater {
    @Override public void work() { System.out.println("Robot working."); }
    @Override public void eat() {
        // Robots don't eat. This method is forced and likely empty or throws exception.
        throw new UnsupportedOperationException("Robots don't eat.");
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="6" id="dependency-inversion-principle">
            <example-header>
                <example-title>Dependency Inversion Principle (DIP)</example-title>
                <example-subtitle>High-level modules should not depend on low-level modules. Both should depend on abstractions.</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Abstractions (e.g., interfaces) should not depend on details. Details (concrete implementations) should depend on abstractions. This promotes loose coupling.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// Abstraction
interface MessageSender {
    void sendMessage(String message);
}

// Low-level module (detail)
class EmailSender implements MessageSender {
    @Override public void sendMessage(String message) { System.out.println("Email sent: " + message); }
}

// Low-level module (detail)
class SMSSender implements MessageSender {
    @Override public void sendMessage(String message) { System.out.println("SMS sent: " + message); }
}

// High-level module
class NotificationService {
    private final MessageSender sender; // Depends on abstraction

    public NotificationService(MessageSender sender) { // Dependency injected
        this.sender = sender;
    }

    public void notify(String message) {
        sender.sendMessage(message);
    }
}

public class DIPExample {
    public static void main(String args) {
        NotificationService emailNotifier = new NotificationService(new EmailSender());
        emailNotifier.notify("Hello via Email!");

        NotificationService smsNotifier = new NotificationService(new SMSSender());
        smsNotifier.notify("Hello via SMS!");
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Bad: High-level module depends directly on low-level module
class EmailerBad {
    public void sendEmail(String message) { System.out.println("Email sent: " + message); }
}

class NotificationServiceBad {
    private EmailerBad emailer; // Direct dependency on concrete EmailerBad

    public NotificationServiceBad() {
        this.emailer = new EmailerBad(); // Instantiates concrete class
    }

    public void sendNotification(String message) {
        emailer.sendEmail(message); // Tightly coupled
    }
    // If we want to use SMSSender, NotificationServiceBad needs to be changed.
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="7" id="dry-dont-repeat-yourself">
            <example-header>
                <example-title>DRY (Don't Repeat Yourself)</example-title>
                <example-subtitle>Avoid duplication of code.</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Every piece of knowledge or logic must have a single, unambiguous, authoritative representation within a system. Use methods, classes, inheritance, or composition to centralize and reuse code.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[class CalculationUtils {
    // Centralized validation logic
    public static void validatePositive(double value, String name) {
        if (value <= 0) {
            throw new IllegalArgumentException(name + " must be positive.");
        }
    }
}

class RectangleArea {
    public double calculate(double width, double height) {
        CalculationUtils.validatePositive(width, "Width");
        CalculationUtils.validatePositive(height, "Height");
        return width * height;
    }
}

class CircleVolume {
    public double calculate(double radius, double height) {
        CalculationUtils.validatePositive(radius, "Radius");
        CalculationUtils.validatePositive(height, "Height");
        return Math.PI * radius * radius * height;
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Bad: Duplicated validation logic
class RectangleAreaBad {
    public double calculate(double width, double height) {
        if (width <= 0) throw new IllegalArgumentException("Width must be positive."); // Duplicated
        if (height <= 0) throw new IllegalArgumentException("Height must be positive."); // Duplicated
        return width * height;
    }
}

class CircleVolumeBad {
    public double calculate(double radius, double height) {
        if (radius <= 0) throw new IllegalArgumentException("Radius must be positive."); // Duplicated
        if (height <= 0) throw new IllegalArgumentException("Height must be positive."); // Duplicated
        return Math.PI * radius * radius * height;
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="8" id="yagni-you-aint-gonna-need-it">
            <example-header>
                <example-title>YAGNI (You Ain't Gonna Need It)</example-title>
                <example-subtitle>Implement features only when you actually need them.</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Avoid implementing functionality based on speculation that it might be needed in the future. This helps prevent over-engineering and keeps the codebase simpler and more focused on current requirements.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// Good: Simple class meeting current needs
class ReportGenerator {
    public String generateSimpleReport(List<String> data) {
        System.out.println("Generating simple report.");
        return "Report: " + String.join(", ", data);
    }
    // If PDF export is needed later, it can be added then.
    // No need to implement generatePdfReport, generateExcelReport etc. upfront.
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Bad: Over-engineered with features not currently needed
class ReportGeneratorOverkill {
    public String generateHtmlReport(List<String> data) { /* ... */ return "html";}
    public byte[] generatePdfReport(List<String> data) {
        System.out.println("Generating PDF report (not actually used yet).");
        return new byte[0];
    }
    public byte[] generateExcelReport(List<String> data) {
        System.out.println("Generating Excel report (not actually used yet).");
        return new byte[0];
    }
    // Current requirement is only for HTML, but PDF and Excel are added "just in case".
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="9" id="design-well-structured-classes-interfaces">
            <example-header>
                <example-title>Design Well-Structured and Maintainable Classes and Interfaces</example-title>
                <example-subtitle>Design Well-Structured and Maintainable Classes and Interfaces</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Good class and interface design is crucial for building flexible and understandable OOD systems. Favor composition over inheritance, program to interfaces rather than implementations, keep classes small and focused, and design for immutability where appropriate. Use clear, descriptive naming conventions.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// Interface (Abstraction)
interface Engine {
    void start();
    void stop();
}

// Concrete Implementations
class PetrolEngine implements Engine {
    @Override public void start() { System.out.println("Petrol engine started."); }
    @Override public void stop() { System.out.println("Petrol engine stopped."); }
}

class ElectricEngine implements Engine {
    @Override public void start() { System.out.println("Electric engine silently started."); }
    @Override public void stop() { System.out.println("Electric engine silently stopped."); }
}

// Class using Composition and Programming to an Interface
class Car {
    private final Engine engine; // Depends on Engine interface (abstraction)
    private final String modelName;

    // Engine is injected (composition)
    public Car(String modelName, Engine engine) {
        this.modelName = modelName;
        this.engine = engine;
    }

    public void startCar() {
        System.out.print(modelName + ": ");
        engine.start();
    }

    public void stopCar() {
        System.out.print(modelName + ": ");
        engine.stop();
    }

    public String getModelName(){ return modelName; }
}

public class ClassDesignExample {
    public static void main(String args) {
        Car petrolCar = new Car("SedanX", new PetrolEngine());
        Car electricCar = new Car("EVMax", new ElectricEngine());

        petrolCar.startCar();
        electricCar.startCar();
        petrolCar.stopCar();
        electricCar.stopCar();
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Bad: Tight coupling, not programming to an interface
class BadCar {
    private final BadPetrolEngine engine; // Direct dependency on concrete BadPetrolEngine
    public BadCar() {
        this.engine = new BadPetrolEngine(); // Instantiates concrete class
    }
    public void start() { engine.startPetrol(); }
    // If we want an electric car, this class needs significant changes or a new similar class.
}
class BadPetrolEngine { public void startPetrol() { System.out.println("Bad petrol engine starts."); } }]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="10" id="utilize-core-oop-concepts">
            <example-header>
                <example-title>Effectively Utilize Core Object-Oriented Concepts</example-title>
                <example-subtitle>Effectively Utilize Core Object-Oriented Concepts</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Encapsulation, Inheritance, and Polymorphism are the three pillars of object-oriented programming.
                ]]>
            </example-description>
        </example>

        <example number="11" id="protect-internal-state">
            <example-header>
                <example-title>Encapsulation</example-title>
                <example-subtitle>Protect Internal State and Implementation Details</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Hide the internal state (fields) and implementation details of an object from the outside world. Expose a well-defined public interface (methods) for interacting with the object. Use access modifiers effectively to control visibility and protect invariants.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[class BankAccount {
    private double balance; // Encapsulated: internal state is private
    private final String accountNumber;

    public BankAccount(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        if (initialBalance < 0) throw new IllegalArgumentException("Initial balance cannot be negative.");
        this.balance = initialBalance;
    }

    // Public interface to interact with the balance
    public void deposit(double amount) {
        if (amount <= 0) throw new IllegalArgumentException("Deposit amount must be positive.");
        this.balance += amount;
        System.out.println("Deposited: " + amount + ", New Balance: " + this.balance);
    }

    public void withdraw(double amount) {
        if (amount <= 0) throw new IllegalArgumentException("Withdrawal amount must be positive.");
        if (amount > this.balance) throw new IllegalArgumentException("Insufficient funds.");
        this.balance -= amount;
        System.out.println("Withdrew: " + amount + ", New Balance: " + this.balance);
    }

    public double getBalance() { // Controlled access to balance
        return this.balance;
    }
    public String getAccountNumber() { return this.accountNumber; }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Bad: Poor encapsulation, exposing internal state
class UnsafeBankAccount {
    public double balance; // Public field: internal state exposed and can be freely modified
    public String accountNumber;

    public UnsafeBankAccount(String accNum, double initial) { this.accountNumber = accNum; this.balance = initial; }
    // No methods to control how balance is changed, invariants can be broken.
}
public class BadEncapsulationExample {
    public static void main(String args) {
        UnsafeBankAccount account = new UnsafeBankAccount("123", 100.0);
        account.balance = -500.0; // Direct modification, potentially breaking business rules
        System.out.println("Unsafe balance: " + account.balance);
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="12" id="model-is-a-relationships">
            <example-header>
                <example-title>Inheritance</example-title>
                <example-subtitle>Model "is-a" Relationships and Ensure LSP</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Use inheritance to model true "is-a" relationships, where a subclass is a more specific type of its superclass. Ensure that the Liskov Substitution Principle (LSP) is followed: subclasses must be substitutable for their base types without altering the correctness of the program.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[abstract class Animal {
    private String name;
    public Animal(String name) { this.name = name; }
    public String getName() { return name; }
    public abstract void makeSound(); // Abstract method for polymorphism
}

class Dog extends Animal { // Dog IS-A Animal
    public Dog(String name) { super(name); }
    @Override public void makeSound() { System.out.println(getName() + " says: Woof!"); }
    public void fetch() { System.out.println(getName() + " is fetching."); }
}

class Cat extends Animal { // Cat IS-A Animal
    public Cat(String name) { super(name); }
    @Override public void makeSound() { System.out.println(getName() + " says: Meow!"); }
    public void purr() { System.out.println(getName() + " is purring."); }
}

public class InheritanceExample {
    public static void main(String args) {
        Animal myDog = new Dog("Buddy");
        Animal myCat = new Cat("Whiskers");
        myDog.makeSound();
        myCat.makeSound();
        // ((Dog)myDog).fetch(); // Can cast if sure of type to access specific methods
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Bad: Incorrect "is-a" relationship using composition instead
class Window {
    public void open() { System.out.println("Window opened."); }
    public void close() { System.out.println("Window closed."); }
}

class BetterCarDoor {
    private WindowComponent window = new WindowComponent();
    public void openDoor() { System.out.println("Car door opened."); }
    public void closeDoor() { System.out.println("Car door closed."); }
    public void openWindow() { window.open(); }
    public void closeWindow() { window.close(); }
    static class WindowComponent { /* Similar to Window */
        public void open() {System.out.println("Car window rolling down.");}
        public void close() {System.out.println("Car window rolling up.");}
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="13" id="objects-respond-differently">
            <example-header>
                <example-title>Polymorphism</example-title>
                <example-subtitle>Enable Objects to Respond to the Same Message Differently</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Polymorphism allows objects of different classes (that share a common superclass or interface) to respond to the same message (method call) in their own specific ways. It simplifies client code, as it can interact with different types of objects through a common interface without needing to know their concrete types.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[interface Drawable {
    void draw();
}

class CircleShape implements Drawable {
    @Override public void draw() { System.out.println("Drawing a Circle: O"); }
}

class SquareShape implements Drawable {
    @Override public void draw() { System.out.println("Drawing a Square: □"); }
}

class TriangleShape implements Drawable {
    @Override public void draw() { System.out.println("Drawing a Triangle: /\\"); }
}

public class PolymorphismExample {
    public static void drawShapes(List<Drawable> shapes) {
        for (Drawable shape : shapes) {
            shape.draw(); // Polymorphic call: actual method executed depends on shape's concrete type
        }
    }
    public static void main(String args) {
        List<Drawable> myShapes = List.of(
            new CircleShape(),
            new SquareShape(),
            new TriangleShape()
        );
        drawShapes(myShapes);
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Bad: Lacking polymorphism, using type checking and casting
class ShapeDrawer {
    public void drawSpecificShape(Object shape) {
        if (shape instanceof CircleShapeBad) {
            ((CircleShapeBad) shape).drawCircle();
        } else if (shape instanceof SquareShapeBad) {
            ((SquareShapeBad) shape).drawSquare();
        } else if (shape instanceof TriangleShapeBad) {
            ((TriangleShapeBad) shape).drawTriangle();
        } else {
            System.out.println("Unknown shape type.");
        }
        // This is not polymorphic. Adding new shapes requires modifying this method.
    }
}

class CircleShapeBad { public void drawCircle() { System.out.println("Drawing Circle (Bad)."); } }
class SquareShapeBad { public void drawSquare() { System.out.println("Drawing Square (Bad)."); } }
class TriangleShapeBad { public void drawTriangle() { System.out.println("Drawing Triangle (Bad)."); } }]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="14" id="recognize-code-smells">
            <example-header>
                <example-title>Recognize and Address Common OOD Code Smells</example-title>
                <example-subtitle>Recognize and Address Common OOD Code Smells</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Code smells are symptoms of potential underlying problems in the design. Recognizing and refactoring them can significantly improve code quality.
                ]]>
            </example-description>
        </example>

        <example number="15" id="large-god-class">
            <example-header>
                <example-title>Large Class / God Class</example-title>
                <example-subtitle>A class that knows or does too much.</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Such classes violate SRP and are hard to understand, maintain, and test. Consider breaking them down into smaller, more focused classes.
                ]]>
            </example-description>
        </example>

        <example number="16" id="feature-envy">
            <example-header>
                <example-title>Feature Envy</example-title>
                <example-subtitle>A method that seems more interested in a class other than the one it actually is in.</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                This often means the method is using data from another class more than its own. Consider moving the method to the class it's "envious" of, or introduce a new class to mediate.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[class Customer {
    private String name;
    private Address address;
    public Customer(String name, Address address) { this.name = name; this.address = address; }
    public String getFullAddressDetails() { // Method operates on its own Address object
        return address.getStreet() + ", " + address.getCity() + ", " + address.getZipCode();
    }
}
class Address {
    private String street, city, zipCode;
    public Address(String s, String c, String z) { street=s; city=c; zipCode=z; }
    public String getStreet() { return street; }
    public String getCity() { return city; }
    public String getZipCode() { return zipCode; }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[class Order {
    private double amount;
    private Customer customer; // Has a Customer
    public Order(double amount, Customer customer) { this.amount = amount; this.customer = customer; }

    // Bad: This method is more interested in Customer's Address than Order itself
    public String getCustomerShippingLabel() {
        Address addr = customer.getAddress(); // Assuming Customer has getAddress()
        return customer.getName() + "\n" + addr.getStreet() +
               "\n" + addr.getCity() + ", " + addr.getZipCode();
        // Better: Move this logic to Customer class as getShippingLabel() or similar.
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="17" id="inappropriate-intimacy">
            <example-header>
                <example-title>Inappropriate Intimacy</example-title>
                <example-subtitle>Classes that spend too much time delving into each other's private parts.</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                This indicates tight coupling and poor encapsulation. Classes should interact through well-defined public interfaces, not by accessing internal implementation details of others.
                ]]>
            </example-description>
            <code-examples>
                <bad-example>
                    <code-block language="java"><![CDATA[class ServiceA {
    public int internalCounter = 0; // Public field, bad
    public void doSomething() { internalCounter++; }
}
class ServiceB {
    public void manipulateServiceA(ServiceA serviceA) {
        // Bad: Directly accessing and modifying internal state of ServiceA
        serviceA.internalCounter = 100;
        System.out.println("ServiceA counter directly set to: " + serviceA.internalCounter);
        // Better: ServiceA should have a method like resetCounter(int value) if this is valid behavior.
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="18" id="refused-bequest">
            <example-header>
                <example-title>Refused Bequest</example-title>
                <example-subtitle>A subclass uses only some of the methods and properties inherited from its parents.</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                This might indicate a violation of LSP or an incorrect inheritance hierarchy. The subclass might not truly be a substitutable type of the superclass.
                ]]>
            </example-description>
        </example>

        <example number="19" id="shotgun-surgery">
            <example-header>
                <example-title>Shotgun Surgery</example-title>
                <example-subtitle>When a single conceptual change requires modifications in many different classes.</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                This often indicates that a single responsibility has been spread too thinly across multiple classes, leading to high coupling and difficulty in making changes.
                ]]>
            </example-description>
        </example>

        <example number="20" id="data-clumps">
            <example-header>
                <example-title>Data Clumps</example-title>
                <example-subtitle>Bunches of data items that regularly appear together in multiple places.</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                These data clumps often represent a missing concept that should be encapsulated into its own object or record.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// Good: Encapsulating related data into a Range object
record DateRange(LocalDate start, LocalDate end) {
    public DateRange {
        if (start.isAfter(end)) throw new IllegalArgumentException("Start date must be before end date.");
    }
}

class EventScheduler {
    public void scheduleEvent(String eventName, DateRange range) {
        System.out.println("Scheduling " + eventName + " from " + range.start() + " to " + range.end());
    }
    public boolean isDateInRange(LocalDate date, DateRange range) {
        return !date.isBefore(range.start()) && !date.isAfter(range.end());
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Bad: Data clump (startDay, startMonth, startYear, endDay, endMonth, endYear) passed around
class EventSchedulerBad {
    public void scheduleEvent(String eventName,
                              int startDay, int startMonth, int startYear,
                              int endDay, int endMonth, int endYear) {
        // ... logic using these separate date parts ...
        System.out.println("Scheduling event with many date parameters.");
    }
    public boolean checkOverlap(int sDay1, int sMon1, int sYr1, int eDay1, int eMon1, int eYr1,
                              int sDay2, int sMon2, int sYr2, int eDay2, int eMon2, int eYr2) {
        // ... complex logic with many parameters ...
        return false;
    }
    // This pattern of passing around many related date parts is a data clump.
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="21" id="creating-destroying-objects">
            <example-header>
                <example-title>Creating and Destroying Objects</example-title>
                <example-subtitle>Best Practices for Object Creation and Destruction</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Effective object creation and destruction patterns improve code clarity, performance, and maintainability. These practices help avoid common pitfalls and leverage Java's capabilities effectively.
                ]]>
            </example-description>
        </example>

        <example number="22" id="static-factory-methods">
            <example-header>
                <example-title>Consider Static Factory Methods Instead of Constructors</example-title>
                <example-subtitle>Use static factory methods to provide more flexibility than constructors</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Static factory methods offer advantages like descriptive names, ability to return existing instances, and flexibility in return types.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class BigInteger {
    // Static factory method with descriptive name
    public static BigInteger valueOf(long val) {
        if (val == 0) return ZERO;  // Return cached instance
        if (val > 0 && val <= MAX_CONSTANT) return posConst[(int) val];
        return new BigInteger(val);
    }

    // Private constructor
    private BigInteger(long val) { /* implementation */ }

    private static final BigInteger ZERO = new BigInteger(0);
    private static final BigInteger[] posConst = new BigInteger[MAX_CONSTANT + 1];
}

// Usage with clear intent
BigInteger zero = BigInteger.valueOf(0);  // Clear what we're creating
BigInteger hundred = BigInteger.valueOf(100);]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class BigInteger {
    // Only constructor available - less flexible
    public BigInteger(long val) { /* implementation */ }

    // Client code is less clear
    BigInteger zero = new BigInteger(0);  // Not clear this could be cached
    BigInteger hundred = new BigInteger(100);  // Creates new instance every time
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="23" id="builder-pattern">
            <example-header>
                <example-title>Consider a Builder When Faced with Many Constructor Parameters</example-title>
                <example-subtitle>Use the Builder pattern for classes with multiple optional parameters</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                The Builder pattern provides a readable alternative to telescoping constructors and is safer than JavaBeans pattern.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    public static class Builder {
        // Required parameters
        private final int servingSize;
        private final int servings;

        // Optional parameters - initialized to default values
        private int calories = 0;
        private int fat = 0;
        private int sodium = 0;
        private int carbohydrate = 0;

        public Builder(int servingSize, int servings) {
            this.servingSize = servingSize;
            this.servings = servings;
        }

        public Builder calories(int val) { calories = val; return this; }
        public Builder fat(int val) { fat = val; return this; }
        public Builder sodium(int val) { sodium = val; return this; }
        public Builder carbohydrate(int val) { carbohydrate = val; return this; }

        public NutritionFacts build() {
            return new NutritionFacts(this);
        }
    }

    private NutritionFacts(Builder builder) {
        servingSize = builder.servingSize;
        servings = builder.servings;
        calories = builder.calories;
        fat = builder.fat;
        sodium = builder.sodium;
        carbohydrate = builder.carbohydrate;
    }
}

// Usage - readable and flexible
NutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)
    .calories(100)
    .sodium(35)
    .carbohydrate(27)
    .build();]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Telescoping constructor pattern - hard to read and error-prone
public class NutritionFacts {
    private final int servingSize;
    private final int servings;
    private final int calories;
    private final int fat;
    private final int sodium;
    private final int carbohydrate;

    public NutritionFacts(int servingSize, int servings) {
        this(servingSize, servings, 0);
    }

    public NutritionFacts(int servingSize, int servings, int calories) {
        this(servingSize, servings, calories, 0);
    }

    public NutritionFacts(int servingSize, int servings, int calories, int fat) {
        this(servingSize, servings, calories, fat, 0);
    }

    public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium) {
        this(servingSize, servings, calories, fat, sodium, 0);
    }

    public NutritionFacts(int servingSize, int servings, int calories, int fat, int sodium, int carbohydrate) {
        this.servingSize = servingSize;
        this.servings = servings;
        this.calories = calories;
        this.fat = fat;
        this.sodium = sodium;
        this.carbohydrate = carbohydrate;
    }
}

// Usage - confusing parameter order, easy to make mistakes
NutritionFacts cocaCola = new NutritionFacts(240, 8, 100, 0, 35, 27);  // What do these numbers mean?]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="24" id="singleton-pattern">
            <example-header>
                <example-title>Enforce the Singleton Property with a Private Constructor or an Enum Type</example-title>
                <example-subtitle>Use enum or private constructor with static field for singletons</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Enum-based singletons are the best way to implement singletons, providing serialization and reflection safety.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// Enum singleton - preferred approach
public enum DatabaseConnection {
    INSTANCE;

    public void connect() {
        System.out.println("Connecting to database...");
    }

    public void executeQuery(String query) {
        System.out.println("Executing: " + query);
    }
}

// Alternative: Static field with private constructor
public class Logger {
    private static final Logger INSTANCE = new Logger();

    private Logger() { /* private constructor */ }

    public static Logger getInstance() {
        return INSTANCE;
    }

    public void log(String message) {
        System.out.println("LOG: " + message);
    }
}

// Usage
DatabaseConnection.INSTANCE.connect();
Logger.getInstance().log("Application started");]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Not thread-safe singleton
public class BadSingleton {
    private static BadSingleton instance;

    private BadSingleton() {}

    public static BadSingleton getInstance() {
        if (instance == null) {  // Race condition possible
            instance = new BadSingleton();
        }
        return instance;
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="25" id="dependency-injection">
            <example-header>
                <example-title>Prefer Dependency Injection to Hardwiring Resources</example-title>
                <example-subtitle>Use dependency injection instead of hardcoded dependencies</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Classes should not create their dependencies directly but receive them from external sources, improving testability and flexibility.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class SpellChecker {
    private final Lexicon dictionary;

    // Dependency injected through constructor
    public SpellChecker(Lexicon dictionary) {
        this.dictionary = Objects.requireNonNull(dictionary);
    }

    public boolean isValid(String word) {
        return dictionary.contains(word);
    }
}

interface Lexicon {
    boolean contains(String word);
}

class EnglishLexicon implements Lexicon {
    public boolean contains(String word) {
        // English dictionary lookup
        return true;
    }
}

// Usage - flexible and testable
Lexicon englishDict = new EnglishLexicon();
SpellChecker checker = new SpellChecker(englishDict);]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Hardwired dependency - inflexible and hard to test
public class SpellChecker {
    private static final Lexicon dictionary = new EnglishLexicon();  // Hardcoded

    private SpellChecker() {}  // Noninstantiable

    public static boolean isValid(String word) {
        return dictionary.contains(word);
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="26" id="avoid-unnecessary-objects">
            <example-header>
                <example-title>Avoid Creating Unnecessary Objects</example-title>
                <example-subtitle>Reuse objects when possible to improve performance</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Object creation can be expensive. Reuse immutable objects and avoid creating objects in loops when possible.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class DateUtils {
    // Reuse expensive objects
    private static final DateTimeFormatter FORMATTER =
        DateTimeFormatter.ofPattern("yyyy-MM-dd");

    public String formatDate(LocalDate date) {
        return FORMATTER.format(date);  // Reuse formatter
    }

    // Use primitives when possible
    public boolean isEven(int number) {
        return number % 2 == 0;  // No object creation
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class DateUtils {
    public String formatDate(LocalDate date) {
        // Creates new formatter every time - expensive
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd");
        return formatter.format(date);
    }

    // Unnecessary autoboxing
    public boolean isEven(Integer number) {
        return number % 2 == 0;  // Creates Integer objects
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="27" id="classes-interfaces-best-practices">
            <example-header>
                <example-title>Classes and Interfaces Best Practices</example-title>
                <example-subtitle>Design Classes and Interfaces for Maximum Effectiveness</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Well-designed classes and interfaces are the foundation of maintainable and robust Java applications. These practices ensure proper encapsulation, inheritance, and interface design.
                ]]>
            </example-description>
        </example>

        <example number="28" id="minimize-accessibility">
            <example-header>
                <example-title>Minimize the Accessibility of Classes and Members</example-title>
                <example-subtitle>Use the most restrictive access level that makes sense</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Proper encapsulation hides implementation details and allows for easier maintenance and evolution of code.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class BankAccount {
    private final String accountNumber;  // Private - implementation detail
    private double balance;              // Private - internal state

    // Package-private for testing
    static final double MINIMUM_BALANCE = 0.0;

    public BankAccount(String accountNumber, double initialBalance) {  // Public - part of API
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    public double getBalance() {  // Public - part of API
        return balance;
    }

    public void deposit(double amount) {  // Public - part of API
        validateAmount(amount);
        balance += amount;
    }

    private void validateAmount(double amount) {  // Private - implementation detail
        if (amount <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class BankAccount {
    public String accountNumber;  // Should be private
    public double balance;        // Should be private
    public static final double MINIMUM_BALANCE = 0.0;  // Unnecessarily public

    public BankAccount(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    public void validateAmount(double amount) {  // Should be private
        if (amount <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="29" id="accessor-methods">
            <example-header>
                <example-title>In Public Classes, Use Accessor Methods, Not Public Fields</example-title>
                <example-subtitle>Provide getter and setter methods instead of exposing fields directly</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Accessor methods provide flexibility to add validation, logging, or other logic without breaking clients.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class Point {
    private double x;
    private double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() { return x; }
    public double getY() { return y; }

    public void setX(double x) {
        // Can add validation or other logic
        if (Double.isNaN(x)) {
            throw new IllegalArgumentException("x cannot be NaN");
        }
        this.x = x;
    }

    public void setY(double y) {
        if (Double.isNaN(y)) {
            throw new IllegalArgumentException("y cannot be NaN");
        }
        this.y = y;
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class Point {
    public double x;  // Direct field access - no validation possible
    public double y;  // Cannot add logic later without breaking clients

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="30" id="minimize-mutability">
            <example-header>
                <example-title>Minimize Mutability</example-title>
                <example-subtitle>Make classes immutable when possible</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Immutable classes are simpler, safer, and can be freely shared. They are inherently thread-safe and have no temporal coupling.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public final class Complex {
    private final double real;
    private final double imaginary;

    public Complex(double real, double imaginary) {
        this.real = real;
        this.imaginary = imaginary;
    }

    public double realPart() { return real; }
    public double imaginaryPart() { return imaginary; }

    // Operations return new instances instead of modifying
    public Complex plus(Complex c) {
        return new Complex(real + c.real, imaginary + c.imaginary);
    }

    public Complex minus(Complex c) {
        return new Complex(real - c.real, imaginary - c.imaginary);
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof Complex)) return false;
        Complex c = (Complex) o;
        return Double.compare(c.real, real) == 0 &&
               Double.compare(c.imaginary, imaginary) == 0;
    }

    @Override
    public int hashCode() {
        return Objects.hash(real, imaginary);
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class Complex {
    private double real;      // Mutable fields
    private double imaginary; // Mutable fields

    public Complex(double real, double imaginary) {
        this.real = real;
        this.imaginary = imaginary;
    }

    public double getRealPart() { return real; }
    public double getImaginaryPart() { return imaginary; }

    // Mutating operations - not thread-safe, harder to reason about
    public void plus(Complex c) {
        this.real += c.real;
        this.imaginary += c.imaginary;
    }

    public void setReal(double real) { this.real = real; }
    public void setImaginary(double imaginary) { this.imaginary = imaginary; }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="31" id="favor-composition-over-inheritance">
            <example-header>
                <example-title>Favor Composition Over Inheritance</example-title>
                <example-subtitle>Use composition instead of inheritance when you want to reuse code</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Composition is more flexible than inheritance and avoids the fragility of inheritance hierarchies.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// Using composition
public class InstrumentedSet<E> {
    private final Set<E> s;
    private int addCount = 0;

    public InstrumentedSet(Set<E> s) {
        this.s = s;
    }

    public boolean add(E e) {
        addCount++;
        return s.add(e);
    }

    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return s.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }

    // Delegate other methods to the wrapped set
    public int size() { return s.size(); }
    public boolean isEmpty() { return s.isEmpty(); }
    public boolean contains(Object o) { return s.contains(o); }
    // ... other delegating methods
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Using inheritance - fragile and error-prone
public class InstrumentedHashSet<E> extends HashSet<E> {
    private int addCount = 0;

    @Override
    public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);  // This calls add() internally, double-counting!
    }

    public int getAddCount() {
        return addCount;
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="32" id="design-document-inheritance">
            <example-header>
                <example-title>Design and Document for Inheritance or Else Prohibit It</example-title>
                <example-subtitle>Either design classes specifically for inheritance or make them final</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Classes not designed for inheritance can break when subclassed. Document self-use patterns or prohibit inheritance.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// Designed for inheritance with proper documentation
public abstract class AbstractProcessor {

    /**
     * Processes the given data. This implementation calls {@link #validate(String)}
     * followed by {@link #transform(String)}. Subclasses may override this method
     * to provide different processing logic.
     *
     * @param data the data to process
     * @return the processed result
     * @throws IllegalArgumentException if data is invalid
     */
    public String process(String data) {
        validate(data);
        return transform(data);
    }

    /**
     * Validates the input data. The default implementation checks for null.
     * Subclasses may override to provide additional validation.
     */
    protected void validate(String data) {
        if (data == null) {
            throw new IllegalArgumentException("Data cannot be null");
        }
    }

    /**
     * Transforms the validated data. Subclasses must implement this method.
     */
    protected abstract String transform(String data);
}

// Or prohibit inheritance
public final class UtilityClass {
    private UtilityClass() { /* prevent instantiation */ }

    public static String formatName(String firstName, String lastName) {
        return firstName + " " + lastName;
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Not designed for inheritance but not prohibited
public class DataProcessor {
    public String process(String data) {
        // Complex logic that might break if overridden
        String validated = validate(data);
        String transformed = transform(validated);
        return finalize(transformed);
    }

    private String validate(String data) { /* ... */ return data; }
    private String transform(String data) { /* ... */ return data; }
    private String finalize(String data) { /* ... */ return data; }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="33" id="enums-annotations">
            <example-header>
                <example-title>Enums and Annotations</example-title>
                <example-subtitle>Effective Use of Enums and Annotations</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Enums and annotations are powerful Java features that, when used correctly, can make code more readable, type-safe, and maintainable.
                ]]>
            </example-description>
        </example>

        <example number="34" id="use-enums-instead-int-constants">
            <example-header>
                <example-title>Use Enums Instead of Int Constants</example-title>
                <example-subtitle>Replace int constants with type-safe enums</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Enums provide type safety, namespace protection, and additional functionality that int constants cannot offer.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public enum Planet {
    MERCURY(3.302e+23, 2.439e6),
    VENUS  (4.869e+24, 6.052e6),
    EARTH  (5.975e+24, 6.378e6),
    MARS   (6.419e+23, 3.393e6);

    private final double mass;           // In kilograms
    private final double radius;         // In meters
    private final double surfaceGravity; // In m / s^2

    // Universal gravitational constant in m^3 / kg s^2
    private static final double G = 6.67300E-11;

    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
        surfaceGravity = G * mass / (radius * radius);
    }

    public double mass()           { return mass; }
    public double radius()         { return radius; }
    public double surfaceGravity() { return surfaceGravity; }

    public double surfaceWeight(double mass) {
        return mass * surfaceGravity;  // F = ma
    }
}

// Usage
double earthWeight = 175;
double mass = earthWeight / Planet.EARTH.surfaceGravity();
for (Planet p : Planet.values()) {
    System.out.printf("Weight on %s is %f%n", p, p.surfaceWeight(mass));
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// Int constants - not type-safe, no namespace
public class Planet {
    public static final int MERCURY = 0;
    public static final int VENUS   = 1;
    public static final int EARTH   = 2;
    public static final int MARS    = 3;

    // Separate arrays for data - error-prone
    private static final double[] MASS = {3.302e+23, 4.869e+24, 5.975e+24, 6.419e+23};
    private static final double[] RADIUS = {2.439e6, 6.052e6, 6.378e6, 3.393e6};

    public static double surfaceWeight(int planet, double mass) {
        // No compile-time checking - could pass any int
        if (planet < 0 || planet >= MASS.length) {
            throw new IllegalArgumentException("Invalid planet: " + planet);
        }
        // Complex calculations with array indexing
        return mass * (6.67300E-11 * MASS[planet] / (RADIUS[planet] * RADIUS[planet]));
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="35" id="use-instance-fields-not-ordinals">
            <example-header>
                <example-title>Use Instance Fields Instead of Ordinals</example-title>
                <example-subtitle>Don't derive values from enum ordinals; use instance fields</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Ordinal values can change when enum constants are reordered, making code fragile.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public enum Ensemble {
    SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),
    SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8),
    NONET(9), DECTET(10), TRIPLE_QUARTET(12);

    private final int numberOfMusicians;

    Ensemble(int size) {
        this.numberOfMusicians = size;
    }

    public int numberOfMusicians() {
        return numberOfMusicians;
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public enum Ensemble {
    SOLO, DUET, TRIO, QUARTET, QUINTET,
    SEXTET, SEPTET, OCTET, NONET, DECTET;

    public int numberOfMusicians() {
        return ordinal() + 1;  // Fragile - breaks if order changes
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="36" id="use-enumset-instead-bit-fields">
            <example-header>
                <example-title>Use EnumSet Instead of Bit Fields</example-title>
                <example-subtitle>Replace bit field enums with EnumSet for better type safety and performance</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                EnumSet provides all the benefits of bit fields with better readability and type safety.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class Text {
    public enum Style { BOLD, ITALIC, UNDERLINE, STRIKETHROUGH }

    // EnumSet - type-safe and efficient
    public void applyStyles(Set<Style> styles) {
        System.out.printf("Applying styles %s to text%n", styles);
        // Implementation here
    }
}

// Usage
text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class Text {
    public static final int STYLE_BOLD          = 1 << 0;  // 1
    public static final int STYLE_ITALIC        = 1 << 1;  // 2
    public static final int STYLE_UNDERLINE     = 1 << 2;  // 4
    public static final int STYLE_STRIKETHROUGH = 1 << 3;  // 8

    // Bit field - not type-safe
    public void applyStyles(int styles) {
        System.out.printf("Applying styles %s to text%n", styles);
        // Implementation here
    }
}

// Usage - error-prone, no type safety
text.applyStyles(STYLE_BOLD | STYLE_ITALIC);]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="37" id="use-enummap-not-ordinal-indexing">
            <example-header>
                <example-title>Use EnumMap Instead of Ordinal Indexing</example-title>
                <example-subtitle>Use EnumMap for enum-keyed data instead of ordinal indexing</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                EnumMap is specifically designed for enum keys and provides better performance and type safety.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public enum Phase {
    SOLID, LIQUID, GAS;

    public enum Transition {
        MELT(SOLID, LIQUID), FREEZE(LIQUID, SOLID),
        BOIL(LIQUID, GAS), CONDENSE(GAS, LIQUID),
        SUBLIME(SOLID, GAS), DEPOSIT(GAS, SOLID);

        private final Phase from;
        private final Phase to;

        Transition(Phase from, Phase to) {
            this.from = from;
            this.to = to;
        }

        // Initialize the phase transition map
        private static final Map<Phase, Map<Phase, Transition>> m =
            Stream.of(values()).collect(groupingBy(t -> t.from,
                () -> new EnumMap<>(Phase.class),
                toMap(t -> t.to, t -> t, (x, y) -> y, () -> new EnumMap<>(Phase.class))));

        public static Transition from(Phase from, Phase to) {
            return m.get(from).get(to);
        }
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public enum Phase {
    SOLID, LIQUID, GAS;

    public enum Transition {
        MELT, FREEZE, BOIL, CONDENSE, SUBLIME, DEPOSIT;

        // Ordinal-based array - fragile and error-prone
        private static final Transition[][] TRANSITIONS = {
            { null,    MELT,     SUBLIME  },  // SOLID
            { FREEZE,  null,     BOIL     },  // LIQUID
            { DEPOSIT, CONDENSE, null     }   // GAS
        };

        public static Transition from(Phase from, Phase to) {
            return TRANSITIONS[from.ordinal()][to.ordinal()];
        }
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="38" id="consistently-use-override-annotation">
            <example-header>
                <example-title>Consistently Use the Override Annotation</example-title>
                <example-subtitle>Always use @Override when overriding methods</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                The @Override annotation catches errors at compile time and makes code more readable.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class Bigram {
    private final char first;
    private final char second;

    public Bigram(char first, char second) {
        this.first = first;
        this.second = second;
    }

    @Override
    public boolean equals(Object o) {  // Correct signature
        if (!(o instanceof Bigram)) return false;
        Bigram b = (Bigram) o;
        return b.first == first && b.second == second;
    }

    @Override
    public int hashCode() {
        return 31 * first + second;
    }

    @Override
    public String toString() {
        return String.format("(%c, %c)", first, second);
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class Bigram {
    private final char first;
    private final char second;

    public Bigram(char first, char second) {
        this.first = first;
        this.second = second;
    }

    // Missing @Override - typo in method signature won't be caught
    public boolean equals(Bigram b) {  // Wrong signature! Should be equals(Object)
        return b.first == first && b.second == second;
    }

    public int hashCode() {  // Missing @Override
        return 31 * first + second;
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="39" id="method-design">
            <example-header>
                <example-title>Method Design</example-title>
                <example-subtitle>Design Methods for Clarity, Safety, and Usability</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Well-designed methods are the building blocks of maintainable code. These practices ensure methods are robust, clear, and easy to use correctly.
                ]]>
            </example-description>
        </example>

        <example number="40" id="check-parameters-validity">
            <example-header>
                <example-title>Check Parameters for Validity</example-title>
                <example-subtitle>Validate method parameters early and clearly</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Fail fast by checking parameters at the beginning of methods. This makes debugging easier and prevents corruption of object state.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class MathUtils {
    /**
     * Returns a BigInteger whose value is (this mod m).
     * @param m the modulus, which must be positive
     * @return this mod m
     * @throws ArithmeticException if m <= 0
     */
    public BigInteger mod(BigInteger m) {
        if (m.signum() <= 0) {
            throw new ArithmeticException("Modulus <= 0: " + m);
        }
        // ... do the computation
        return this;
    }

    /**
     * Returns the index of the first occurrence of needle in haystack,
     * or -1 if needle is not contained in haystack.
     * @param haystack the string to search in
     * @param needle the string to search for
     * @throws NullPointerException if haystack or needle is null
     */
    public static int indexOf(String haystack, String needle) {
        Objects.requireNonNull(haystack, "haystack");
        Objects.requireNonNull(needle, "needle");
        // ... do the search
        return haystack.indexOf(needle);
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class MathUtils {
    public BigInteger mod(BigInteger m) {
        // No parameter validation - could cause confusing errors later
        // ... do the computation
        return this;
    }

    public static int indexOf(String haystack, String needle) {
        // No null checks - will throw NullPointerException at some random point
        return haystack.indexOf(needle);
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="41" id="make-defensive-copies">
            <example-header>
                <example-title>Make Defensive Copies When Needed</example-title>
                <example-subtitle>Protect against malicious or accidental modification of mutable parameters</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                When accepting mutable objects as parameters or returning them, make defensive copies to maintain class invariants.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public final class Period {
    private final Date start;
    private final Date end;

    /**
     * @param start the beginning of the period
     * @param end the end of the period; must not precede start
     * @throws IllegalArgumentException if start is after end
     * @throws NullPointerException if start or end is null
     */
    public Period(Date start, Date end) {
        this.start = new Date(start.getTime());  // Defensive copy
        this.end = new Date(end.getTime());      // Defensive copy

        if (this.start.compareTo(this.end) > 0) {
            throw new IllegalArgumentException(this.start + " after " + this.end);
        }
    }

    public Date start() {
        return new Date(start.getTime());  // Defensive copy on return
    }

    public Date end() {
        return new Date(end.getTime());    // Defensive copy on return
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public final class Period {
    private final Date start;
    private final Date end;

    public Period(Date start, Date end) {
        if (start.compareTo(end) > 0) {
            throw new IllegalArgumentException(start + " after " + end);
        }
        this.start = start;  // No defensive copy - client can modify after construction
        this.end = end;      // No defensive copy - client can modify after construction
    }

    public Date start() {
        return start;  // No defensive copy - client can modify internal state
    }

    public Date end() {
        return end;    // No defensive copy - client can modify internal state
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="42" id="design-method-signatures-carefully">
            <example-header>
                <example-title>Design Method Signatures Carefully</example-title>
                <example-subtitle>Choose method names carefully and avoid long parameter lists</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Good method signatures are self-documenting and hard to use incorrectly.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class UserService {
    // Clear, descriptive method names
    public User createUser(String username, String email, LocalDate birthDate) {
        // Implementation
        return new User(username, email, birthDate);
    }

    // Use builder pattern for many parameters
    public static class UserBuilder {
        private String username;
        private String email;
        private LocalDate birthDate;
        private String firstName;
        private String lastName;
        private Address address;

        public UserBuilder username(String username) { this.username = username; return this; }
        public UserBuilder email(String email) { this.email = email; return this; }
        public UserBuilder birthDate(LocalDate birthDate) { this.birthDate = birthDate; return this; }
        public UserBuilder firstName(String firstName) { this.firstName = firstName; return this; }
        public UserBuilder lastName(String lastName) { this.lastName = lastName; return this; }
        public UserBuilder address(Address address) { this.address = address; return this; }

        public User build() {
            return new User(this);
        }
    }

    // Use helper classes to group related parameters
    public void updateUserProfile(User user, ProfileUpdate update) {
        // Implementation
    }
}

class ProfileUpdate {
    private final String firstName;
    private final String lastName;
    private final Address address;

    // Constructor and getters
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class UserService {
    // Unclear method name and too many parameters
    public User doUserStuff(String s1, String s2, int d, int m, int y,
                           String s3, String s4, String s5, String s6, String s7) {
        // What do these parameters mean?
        return new User(s1, s2, LocalDate.of(y, m, d));
    }

    // Ambiguous parameter types
    public void updateUser(String username, String data) {
        // What kind of data? How is it formatted?
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="43" id="return-empty-collections-not-nulls">
            <example-header>
                <example-title>Return Empty Collections or Arrays, Not Nulls</example-title>
                <example-subtitle>Never return null from methods that return collections or arrays</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Returning null forces clients to handle null checks and is a common source of bugs.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class ShoppingCart {
    private final List<Item> items = new ArrayList<>();

    /**
     * Returns a list of items in the cart.
     * @return the items in the cart (never null, but may be empty)
     */
    public List<Item> getItems() {
        return new ArrayList<>(items);  // Return copy of list, never null
    }

    /**
     * Returns items matching the given category.
     * @param category the category to filter by
     * @return matching items (never null, but may be empty)
     */
    public List<Item> getItemsByCategory(String category) {
        return items.stream()
                   .filter(item -> category.equals(item.getCategory()))
                   .collect(Collectors.toList());  // Returns empty list if no matches
    }

    /**
     * Returns an array of item names.
     * @return array of item names (never null, but may be empty)
     */
    public String[] getItemNames() {
        return items.stream()
                   .map(Item::getName)
                   .toArray(String[]::new);  // Returns empty array if no items
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class ShoppingCart {
    private final List<Item> items = new ArrayList<>();

    public List<Item> getItems() {
        return items.isEmpty() ? null : new ArrayList<>(items);  // Bad: returns null
    }

    public List<Item> getItemsByCategory(String category) {
        List<Item> result = items.stream()
                                .filter(item -> category.equals(item.getCategory()))
                                .collect(Collectors.toList());
        return result.isEmpty() ? null : result;  // Bad: returns null
    }

    public String[] getItemNames() {
        if (items.isEmpty()) {
            return null;  // Bad: returns null instead of empty array
        }
        return items.stream()
                   .map(Item::getName)
                   .toArray(String[]::new);
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="44" id="return-optionals-judiciously">
            <example-header>
                <example-title>Return Optionals Judiciously</example-title>
                <example-subtitle>Use Optional for methods that may not return a value, but use it carefully</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Optional is intended for return types where there might legitimately be no result and the client needs to perform special processing.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class UserRepository {
    private final Map<String, User> users = new HashMap<>();

    /**
     * Finds a user by username.
     * @param username the username to search for
     * @return an Optional containing the user if found, empty otherwise
     */
    public Optional<User> findByUsername(String username) {
        return Optional.ofNullable(users.get(username));
    }

    /**
     * Gets the maximum age among all users.
     * @return an Optional containing the max age if users exist, empty otherwise
     */
    public OptionalInt getMaxAge() {
        return users.values().stream()
                   .mapToInt(User::getAge)
                   .max();
    }
}

// Usage
Optional<User> user = repository.findByUsername("john");
if (user.isPresent()) {
    System.out.println("Found user: " + user.get().getName());
} else {
    System.out.println("User not found");
}

// Or with functional style
repository.findByUsername("john")
         .ifPresentOrElse(
             u -> System.out.println("Found: " + u.getName()),
             () -> System.out.println("User not found")
         );]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class UserRepository {
    private final Map<String, User> users = new HashMap<>();

    // Bad: Using Optional for fields
    private Optional<String> defaultUsername = Optional.empty();

    // Bad: Using Optional for parameters
    public void updateUser(Optional<String> username, Optional<String> email) {
        // This makes the API harder to use
    }

    // Bad: Using Optional for collections
    public Optional<List<User>> getAllUsers() {
        return users.isEmpty() ? Optional.empty() : Optional.of(new ArrayList<>(users.values()));
        // Should just return empty list instead
    }

    // Bad: Optional in performance-critical code where null would be fine
    public Optional<User> findByUsernameInLoop(String username) {
        // If this is called in a tight loop, the Optional allocation overhead matters
        return Optional.ofNullable(users.get(username));
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="45" id="exception-handling">
            <example-header>
                <example-title>Exception Handling</example-title>
                <example-subtitle>Handle Exceptions Effectively and Appropriately</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Proper exception handling makes code more robust and easier to debug. These practices ensure exceptions are used correctly and provide meaningful information.
                ]]>
            </example-description>
        </example>

        <example number="46" id="use-exceptions-only-exceptional-conditions">
            <example-header>
                <example-title>Use Exceptions Only for Exceptional Conditions</example-title>
                <example-subtitle>Don't use exceptions for ordinary control flow</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Exceptions should be used for exceptional conditions, not for normal program flow. They are expensive and make code harder to understand.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class NumberProcessor {
    public void processNumbers(int[] numbers) {
        for (int number : numbers) {  // Normal iteration
            if (isValid(number)) {    // Normal condition checking
                process(number);
            } else {
                System.out.println("Skipping invalid number: " + number);
            }
        }
    }

    private boolean isValid(int number) {
        return number >= 0 && number <= 1000;
    }

    private void process(int number) {
        // Process the number
        System.out.println("Processing: " + number);
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class NumberProcessor {
    public void processNumbers(int[] numbers) {
        try {
            int i = 0;
            while (true) {  // Using exception for loop termination
                process(numbers[i++]);
            }
        } catch (ArrayIndexOutOfBoundsException e) {
            // Using exception for normal control flow - bad!
        }
    }

    private void process(int number) {
        System.out.println("Processing: " + number);
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="47" id="use-checked-exceptions-for-recoverable-conditions">
            <example-header>
                <example-title>Use Checked Exceptions for Recoverable Conditions and Runtime Exceptions for Programming Errors</example-title>
                <example-subtitle>Choose the right type of exception for the situation</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Checked exceptions force the caller to handle recoverable conditions, while runtime exceptions indicate programming errors.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class FileProcessor {
    /**
     * Processes a file. Throws checked exception for recoverable I/O issues.
     */
    public void processFile(String filename) throws FileProcessingException {
        try {
            // File operations that might fail due to external factors
            Files.readAllLines(Paths.get(filename));
        } catch (IOException e) {
            // Wrap in domain-specific checked exception
            throw new FileProcessingException("Failed to process file: " + filename, e);
        }
    }

    /**
     * Validates input parameters. Throws runtime exception for programming errors.
     */
    public void validateInput(String input) {
        if (input == null) {
            // Programming error - should never happen in correct code
            throw new IllegalArgumentException("Input cannot be null");
        }
        if (input.trim().isEmpty()) {
            // Programming error - caller should validate before calling
            throw new IllegalArgumentException("Input cannot be empty");
        }
    }
}

// Custom checked exception for recoverable conditions
class FileProcessingException extends Exception {
    public FileProcessingException(String message, Throwable cause) {
        super(message, cause);
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class FileProcessor {
    // Bad: Using checked exception for programming error
    public void validateInput(String input) throws ValidationException {
        if (input == null) {
            throw new ValidationException("Input cannot be null");  // Should be RuntimeException
        }
    }

    // Bad: Using runtime exception for recoverable condition
    public void processFile(String filename) {
        try {
            Files.readAllLines(Paths.get(filename));
        } catch (IOException e) {
            // Should be checked exception so caller can handle
            throw new RuntimeException("File processing failed", e);
        }
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="48" id="favor-standard-exceptions">
            <example-header>
                <example-title>Favor the Use of Standard Exceptions</example-title>
                <example-subtitle>Use standard Java exceptions when appropriate</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Standard exceptions are familiar to developers and have clear semantics. Don't reinvent the wheel.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class Calculator {
    public double divide(double dividend, double divisor) {
        if (divisor == 0.0) {
            throw new ArithmeticException("Division by zero");  // Standard exception
        }
        return dividend / divisor;
    }

    public int getElement(List<Integer> list, int index) {
        Objects.requireNonNull(list, "list");  // Standard NullPointerException
        if (index < 0 || index >= list.size()) {
            throw new IndexOutOfBoundsException("Index: " + index + ", Size: " + list.size());
        }
        return list.get(index);
    }

    public void processPositiveNumber(int number) {
        if (number <= 0) {
            throw new IllegalArgumentException("Number must be positive: " + number);
        }
        // Process the number
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class Calculator {
    public double divide(double dividend, double divisor) {
        if (divisor == 0.0) {
            throw new DivisionByZeroException("Cannot divide by zero");  // Custom exception when standard would do
        }
        return dividend / divisor;
    }

    public int getElement(List<Integer> list, int index) {
        if (list == null) {
            throw new ListIsNullException("List cannot be null");  // Custom exception when standard would do
        }
        if (index < 0 || index >= list.size()) {
            throw new InvalidIndexException("Bad index: " + index);  // Custom exception when standard would do
        }
        return list.get(index);
    }
}

// Unnecessary custom exceptions
class DivisionByZeroException extends RuntimeException {
    public DivisionByZeroException(String message) {
        super(message);
    }
}
class ListIsNullException extends RuntimeException {
    public ListIsNullException(String message) {
        super(message);
    }
}
class InvalidIndexException extends RuntimeException {
    public InvalidIndexException(String message) {
        super(message);
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="49" id="include-failure-capture-information">
            <example-header>
                <example-title>Include Failure-Capture Information in Detail Messages</example-title>
                <example-subtitle>Provide detailed, actionable information in exception messages</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Exception messages should contain all information needed to diagnose the failure.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class BankAccount {
    private double balance;
    private final String accountNumber;

    public BankAccount(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    public void withdraw(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException(
                String.format("Withdrawal amount must be positive. Account: %s, Amount: %.2f",
                             accountNumber, amount));
        }
        if (amount > balance) {
            throw new InsufficientFundsException(
                String.format("Insufficient funds. Account: %s, Balance: %.2f, Requested: %.2f",
                             accountNumber, balance, amount));
        }
        balance -= amount;
    }

    public void transfer(BankAccount toAccount, double amount) {
        if (toAccount == null) {
            throw new IllegalArgumentException(
                String.format("Destination account cannot be null. Source account: %s, Amount: %.2f",
                             accountNumber, amount));
        }
        if (toAccount.accountNumber.equals(this.accountNumber)) {
            throw new IllegalArgumentException(
                String.format("Cannot transfer to same account. Account: %s, Amount: %.2f",
                             accountNumber, amount));
        }
        withdraw(amount);
        toAccount.deposit(amount);
    }

    public void deposit(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException(
                String.format("Deposit amount must be positive. Account: %s, Amount: %.2f",
                             accountNumber, amount));
        }
        balance += amount;
    }
}

class InsufficientFundsException extends RuntimeException {
    public InsufficientFundsException(String message) {
        super(message);
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class BankAccount {
    private double balance;
    private final String accountNumber;

    public void withdraw(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Invalid amount");  // Too vague
        }
        if (amount > balance) {
            throw new InsufficientFundsException("Not enough money");  // No specific details
        }
        balance -= amount;
    }

    public void transfer(BankAccount toAccount, double amount) {
        if (toAccount == null) {
            throw new IllegalArgumentException("Bad account");  // No context
        }
        if (toAccount.accountNumber.equals(this.accountNumber)) {
            throw new IllegalArgumentException("Error");  // Completely unhelpful
        }
        withdraw(amount);
        toAccount.deposit(amount);
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="50" id="dont-ignore-exceptions">
            <example-header>
                <example-title>Don't Ignore Exceptions</example-title>
                <example-subtitle>Always handle exceptions appropriately, never ignore them silently</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Ignoring exceptions can hide bugs and make debugging extremely difficult.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[public class FileManager {
    private static final Logger logger = LoggerFactory.getLogger(FileManager.class);

    public Optional<String> readFileContent(String filename) {
        try {
            return Optional.of(Files.readString(Paths.get(filename)));
        } catch (IOException e) {
            // Log the exception with context
            logger.warn("Failed to read file: {}", filename, e);
            return Optional.empty();  // Return meaningful result
        }
    }

    public void saveToFile(String filename, String content) throws FileOperationException {
        try {
            Files.writeString(Paths.get(filename), content);
            logger.info("Successfully saved content to file: {}", filename);
        } catch (IOException e) {
            // Re-throw as domain-specific exception with context
            throw new FileOperationException("Failed to save content to file: " + filename, e);
        }
    }

    public void cleanupTempFiles(List<String> tempFiles) {
        for (String tempFile : tempFiles) {
            try {
                Files.deleteIfExists(Paths.get(tempFile));
            } catch (IOException e) {
                // Log but continue with other files
                logger.warn("Failed to delete temporary file: {}", tempFile, e);
            }
        }
    }
}

class FileOperationException extends Exception {
    public FileOperationException(String message, Throwable cause) {
        super(message, cause);
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[public class FileManager {
    public String readFileContent(String filename) {
        try {
            return Files.readString(Paths.get(filename));
        } catch (IOException e) {
            // Silently ignoring exception - very bad!
        }
        return null;  // Caller has no idea what went wrong
    }

    public void saveToFile(String filename, String content) {
        try {
            Files.writeString(Paths.get(filename), content);
        } catch (IOException e) {
            // Empty catch block - hiding the problem
        }
    }

    public void processFiles(List<String> files) {
        for (String file : files) {
            try {
                // Some file processing
                Files.readString(Paths.get(file));
            } catch (Exception e) {
                // Catching Exception is too broad, and then ignoring it
            }
        }
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

    </examples>

    <output-requirements-section>
        <output-requirements-list>
            <output-requirements-item>Apply object-oriented design principles to improve code quality and maintainability</output-requirements-item>
            <output-requirements-item>Refactor code to follow SOLID principles and eliminate design smells</output-requirements-item>
            <output-requirements-item>Verify code changes compile and pass tests</output-requirements-item>
        </output-requirements-list>
    </output-requirements-section>
</prompt>
