---
description: Java Object-Oriented Design Guidelines
globs: *.java
alwaysApply: false
---
# Java Object-Oriented Design Guidelines

## System prompt characterization

Role definition: You are a Senior software engineer with extensive experience in Java software development

## Description

This document provides comprehensive guidelines for robust Java object-oriented design and refactoring. It emphasizes core principles like SOLID, DRY, and YAGNI, best practices for class and interface design including favoring composition over inheritance and designing for immutability. The rules also cover mastering encapsulation, inheritance, and polymorphism, and finally, identifying and refactoring common object-oriented design code smells such as God Classes, Feature Envy, and Data Clumps to promote maintainable, flexible, and understandable code.

## Table of contents

- Rule 1: Adhere to Core Design Principles (SOLID, DRY, YAGNI)
- Rule 2: Follow Best Practices for Class and Interface Design
- Rule 3: Master Encapsulation, Inheritance, and Polymorphism
- Rule 4: Identify and Refactor Object-Oriented Design Code Smells

## Rule 1: Adhere to Core Design Principles (SOLID, DRY, YAGNI)

Title: Apply Fundamental Software Design Principles
Description: Core principles like SOLID, DRY, and YAGNI are foundational to good object-oriented design, leading to more robust, maintainable, and understandable systems. These principles should guide all design decisions and help create systems that are flexible and resistant to change.

**Good example:**

```java
// Good: Separate responsibilities following SRP
class UserData {
    private String name;
    private String email;

    public UserData(String name, String email) {
        this.name = name;
        this.email = email;
    }

    public String getName() { return name; }
    public String getEmail() { return email; }
}

class UserPersistence {
    public void saveUser(UserData user) {
        System.out.println("Saving user " + user.getName() + " to database.");
        // Database saving logic
    }
}

class UserEmailer {
    public void sendWelcomeEmail(UserData user) {
        System.out.println("Sending welcome email to " + user.getEmail());
        // Email sending logic
    }
}
```

**Bad example:**

```java
// Bad: User class with multiple responsibilities
class User {
    private String name;
    private String email;

    public User(String name, String email) { this.name = name; this.email = email; }

    public String getName() { return name; }
    public String getEmail() { return email; }

    public void saveToDatabase() {
        System.out.println("Saving user " + name + " to database.");
        // Database logic mixed in
    }

    public void sendWelcomeEmail() {
        System.out.println("Sending welcome email to " + email);
        // Email logic mixed in
    }
    // If email sending changes, or DB logic changes, this class needs to change.
}
```

## Rule 2: Follow Best Practices for Class and Interface Design

Title: Design Well-Structured and Maintainable Classes and Interfaces
Description: Good class and interface design is crucial for building flexible and understandable OOD systems. Favor composition over inheritance, program to interfaces rather than implementations, keep classes small and focused, and design for immutability where appropriate. Use clear, descriptive naming conventions.

**Good example:**

```java
// Interface (Abstraction)
interface Engine {
    void start();
    void stop();
}

// Concrete Implementations
class PetrolEngine implements Engine {
    @Override public void start() { System.out.println("Petrol engine started."); }
    @Override public void stop() { System.out.println("Petrol engine stopped."); }
}

class ElectricEngine implements Engine {
    @Override public void start() { System.out.println("Electric engine silently started."); }
    @Override public void stop() { System.out.println("Electric engine silently stopped."); }
}

// Class using Composition and Programming to an Interface
class Car {
    private final Engine engine; // Depends on Engine interface (abstraction)
    private final String modelName;

    // Engine is injected (composition)
    public Car(String modelName, Engine engine) {
        this.modelName = modelName;
        this.engine = engine;
    }

    public void startCar() {
        System.out.print(modelName + ": ");
        engine.start();
    }

    public void stopCar() {
        System.out.print(modelName + ": ");
        engine.stop();
    }

    public String getModelName() { return modelName; }
}
```

**Bad example:**

```java
// Bad: Tight coupling, not programming to an interface
class BadCar {
    private final BadPetrolEngine engine; // Direct dependency on concrete BadPetrolEngine

    public BadCar() {
        this.engine = new BadPetrolEngine(); // Instantiates concrete class
    }

    public void start() { engine.startPetrol(); }
    // If we want an electric car, this class needs significant changes or a new similar class.
}

class BadPetrolEngine {
    public void startPetrol() { System.out.println("Bad petrol engine starts."); }
}
```

## Rule 3: Master Encapsulation, Inheritance, and Polymorphism

Title: Effectively Utilize Core Object-Oriented Concepts
Description: Encapsulation, Inheritance, and Polymorphism are the three pillars of object-oriented programming. Proper encapsulation protects internal state and exposes behavior through well-defined interfaces. Inheritance should model true "is-a" relationships following the Liskov Substitution Principle. Polymorphism allows objects of different types to be treated uniformly.

**Good example:**

```java
// Good: Proper encapsulation with validation
class BankAccount {
    private double balance; // Encapsulated - cannot be directly accessed
    private final String accountNumber;

    public BankAccount(String accountNumber, double initialBalance) {
        if (initialBalance < 0) {
            throw new IllegalArgumentException("Initial balance cannot be negative");
        }
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
    }

    public void deposit(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Deposit amount must be positive");
        }
        balance += amount;
    }

    public boolean withdraw(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Withdrawal amount must be positive");
        }
        if (amount <= balance) {
            balance -= amount;
            return true;
        }
        return false;
    }

    public double getBalance() { return balance; } // Controlled access
    public String getAccountNumber() { return accountNumber; }
}
```

**Bad example:**

```java
// Bad: Poor encapsulation - direct field access
class BadBankAccount {
    public double balance; // Public field - no validation or control
    public String accountNumber; // Can be modified directly

    public BadBankAccount(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance; // No validation
    }

    // No methods to control access or validate operations
}

// Usage problems:
// BadBankAccount account = new BadBankAccount("123", 100);
// account.balance = -500; // Negative balance allowed!
// account.accountNumber = null; // Can break account number
```

## Rule 4: Identify and Refactor Object-Oriented Design Code Smells

Title: Recognize and Fix Common Design Anti-Patterns
Description: Develop the ability to identify common object-oriented design "code smells" such as God Class, Feature Envy, Data Clumps, and Refused Bequest. Recognizing and refactoring these smells is crucial for improving the long-term health, maintainability, and clarity of the codebase.

**Good example:**

```java
// Good: Refactored from God Class - separate responsibilities
class Order {
    private final String orderId;
    private final List<OrderItem> items;
    private final Customer customer;

    public Order(String orderId, Customer customer) {
        this.orderId = orderId;
        this.customer = customer;
        this.items = new ArrayList<>();
    }

    public void addItem(OrderItem item) { items.add(item); }
    public List<OrderItem> getItems() { return Collections.unmodifiableList(items); }
    public Customer getCustomer() { return customer; }
    public String getOrderId() { return orderId; }
}

class OrderCalculator {
    public BigDecimal calculateTotal(Order order) {
        return order.getItems().stream()
            .map(item -> item.getPrice().multiply(BigDecimal.valueOf(item.getQuantity())))
            .reduce(BigDecimal.ZERO, BigDecimal::add);
    }
}

class OrderValidator {
    public boolean isValid(Order order) {
        return !order.getItems().isEmpty() &&
               order.getCustomer() != null &&
               order.getCustomer().hasValidPaymentMethod();
    }
}
```

**Bad example:**

```java
// Bad: God Class - doing too many things
class OrderManager {
    private String orderId;
    private List<OrderItem> items;
    private Customer customer;
    private PaymentProcessor paymentProcessor;
    private InventoryService inventoryService;
    private EmailService emailService;
    private TaxCalculator taxCalculator;

    // Dozens of methods doing various unrelated things:
    public void addItem(OrderItem item) { /* ... */ }
    public void removeItem(String itemId) { /* ... */ }
    public BigDecimal calculateSubtotal() { /* ... */ }
    public BigDecimal calculateTax() { /* ... */ }
    public BigDecimal calculateShipping() { /* ... */ }
    public boolean validateInventory() { /* ... */ }
    public void processPayment() { /* ... */ }
    public void sendConfirmationEmail() { /* ... */ }
    public void updateInventory() { /* ... */ }
    public void generateInvoice() { /* ... */ }
    public void trackShipment() { /* ... */ }
    // ... many more methods

    // This class has too many responsibilities and reasons to change
}
```
