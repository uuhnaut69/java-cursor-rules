---
description: Type Design Thinking in Java
globs: *.java
alwaysApply: false
---
# Type Design Thinking in Java

## System prompt characterization

Role definition: You are a Senior software engineer with extensive experience in Java software development

## Description

Type design thinking in Java applies typography principles to code structure and organization. Just as typography creates readable, accessible text, thoughtful type design in Java produces maintainable, comprehensible code. This document focuses on establishing clear type hierarchies, using consistent naming conventions, leveraging generics effectively, and creating type-safe wrappers that communicate intent clearly.

## Table of contents

- Rule 1: Establish a Clear Type Hierarchy
- Rule 2: Use Consistent Naming Conventions
- Rule 3: Create Type-Safe Wrappers
- Rule 4: Leverage Generic Type Parameters
- Rule 5: Use BigDecimal for Precision-Sensitive Calculations

## Rule 1: Establish a Clear Type Hierarchy

Title: Organize Classes and Interfaces into Logical Structure
Description: This rule focuses on organizing classes and interfaces into a logical structure using inheritance and composition. A clear hierarchy makes the relationships between types explicit, improving code navigation and understanding. It often involves using nested static classes for closely related types.

**Good example:**

```java
// GOOD: Clear type hierarchy with descriptive names
public class OrderManagement {
    public static class Order {
        private List<OrderItem> items;
        private Customer customer;
        private OrderStatus status;

        public Order(Customer customer) {
            this.customer = customer;
            this.items = new ArrayList<>();
            this.status = OrderStatus.PENDING;
        }

        public void addItem(OrderItem item) { items.add(item); }
        public List<OrderItem> getItems() { return Collections.unmodifiableList(items); }
        public Customer getCustomer() { return customer; }
        public OrderStatus getStatus() { return status; }
    }

    public static class OrderItem {
        private Product product;
        private int quantity;
        private BigDecimal unitPrice;

        public OrderItem(Product product, int quantity, BigDecimal unitPrice) {
            this.product = product;
            this.quantity = quantity;
            this.unitPrice = unitPrice;
        }

        public Product getProduct() { return product; }
        public int getQuantity() { return quantity; }
        public BigDecimal getUnitPrice() { return unitPrice; }
        public BigDecimal getTotalPrice() { return unitPrice.multiply(BigDecimal.valueOf(quantity)); }
    }

    public enum OrderStatus {
        PENDING, CONFIRMED, SHIPPED, DELIVERED, CANCELLED
    }
}
```

**Bad example:**

```java
// AVOID: Flat structure with ambiguous names
public class Order {
    private List<Item> items; // What kind of item?
    private User user; // Is this a customer, admin, or something else?
    private int status; // What do the numbers mean?
    // ...
}

public class Item { // Too generic - what kind of item?
    private Thing thing; // What is a "thing"?
    private int count;
    // ...
}

public class User { // Too generic - could be any type of user
    private String data; // What kind of data?
    // ...
}
```

## Rule 2: Use Consistent Naming Conventions

Title: Apply Uniform Patterns for Naming (Your Type's "Font Family")
Description: This rule emphasizes using uniform patterns for naming classes, interfaces, methods, and variables. Consistency in naming acts like a consistent font family in typography, making the code easier to read, predict, and maintain across the entire project.

**Good example:**

```java
// GOOD: Consistent naming patterns
interface PaymentProcessor {
    PaymentResult process(Payment payment);
}

interface ShippingCalculator {
    BigDecimal calculate(ShippingRequest request);
}

interface TaxProvider {
    Tax calculateTax(TaxableItem item, Address address);
}

// Implementation classes follow consistent naming
class StripePaymentProcessor implements PaymentProcessor {
    @Override
    public PaymentResult process(Payment payment) {
        // Stripe-specific implementation
        return new PaymentResult(true, "Payment processed successfully");
    }
}

class StandardShippingCalculator implements ShippingCalculator {
    @Override
    public BigDecimal calculate(ShippingRequest request) {
        // Standard shipping calculation logic
        return request.getWeight().multiply(new BigDecimal("0.50"));
    }
}
```

**Bad example:**

```java
// AVOID: Inconsistent naming patterns
interface PaymentProcessor {
    void handlePayment(Payment p); // Different method naming style
}

interface ShipCalc { // Inconsistent interface naming
    BigDecimal getShippingCost(Order o); // Different parameter naming
}

interface TaxSystem { // Different naming convention
    Tax lookupTaxRate(Address addr); // Abbreviated parameter name
}

// Implementation classes also inconsistent
class PaymentHandler implements PaymentProcessor { // Handler vs Processor
    @Override
    public void handlePayment(Payment p) {
        // Implementation
    }
}

class ShippingCostCalculatorImpl implements ShipCalc { // Too verbose
    @Override
    public BigDecimal getShippingCost(Order o) {
        // Implementation
    }
}
```

## Rule 3: Create Type-Safe Wrappers

Title: Use Types as Communication Tools
Description: This rule encourages wrapping primitive types or general-purpose types (like String) in domain-specific types. These wrapper types enhance type safety by enforcing invariants at compile-time and clearly communicate the intended meaning and constraints of data.

**Good example:**

```java
// GOOD: Type-safe wrappers communicate intent
public class EmailAddress {
    private final String value;

    public EmailAddress(String email) {
        if (!isValid(email)) {
            throw new IllegalArgumentException("Invalid email format: " + email);
        }
        this.value = email;
    }

    public String getValue() {
        return value;
    }

    private boolean isValid(String email) {
        return email != null &&
               email.matches("^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$") &&
               email.length() <= 254; // RFC 5321 limit
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        EmailAddress that = (EmailAddress) obj;
        return Objects.equals(value, that.value);
    }

    @Override
    public int hashCode() {
        return Objects.hash(value);
    }

    @Override
    public String toString() {
        return value;
    }
}

public class Money {
    private final BigDecimal amount;
    private final Currency currency;

    public Money(BigDecimal amount, Currency currency) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Amount cannot be null or negative");
        }
        this.amount = amount.setScale(currency.getDefaultFractionDigits(), RoundingMode.HALF_UP);
        this.currency = Objects.requireNonNull(currency, "Currency cannot be null");
    }

    public BigDecimal getAmount() { return amount; }
    public Currency getCurrency() { return currency; }

    public Money add(Money other) {
        if (!currency.equals(other.currency)) {
            throw new IllegalArgumentException("Cannot add different currencies");
        }
        return new Money(amount.add(other.amount), currency);
    }
}

// Usage - type safety prevents errors
void processPayment(EmailAddress customerEmail, Money paymentAmount) {
    // We know email is valid and amount is positive with proper currency
    paymentService.charge(customerEmail.getValue(), paymentAmount);
}
```

**Bad example:**

```java
// AVOID: Primitive obsession
void processPayment(String email, double amount, String currency) {
    // Need to validate every time - error prone
    if (email == null || !email.matches("^[\\w-\\.]+@([\\w-]+\\.)+[\\w-]{2,4}$")) {
        throw new IllegalArgumentException("Invalid email");
    }
    if (amount <= 0) {
        throw new IllegalArgumentException("Amount must be positive");
    }
    if (currency == null || currency.length() != 3) {
        throw new IllegalArgumentException("Invalid currency code");
    }

    // Still risky - what if someone passes parameters in wrong order?
    paymentService.charge(email, amount, currency);
}

// Easy to make mistakes:
// processPayment("USD", 100.0, "john@example.com"); // Wrong parameter order!
// processPayment("invalid-email", -50.0, "XXX"); // Invalid values
```

## Rule 4: Leverage Generic Type Parameters

Title: Create Flexible and Reusable Types (Responsive Typography)
Description: This rule promotes the use of generics to create flexible and reusable types and methods that can operate on objects of various types while maintaining type safety. This is akin to responsive typography that adapts to different screen sizes, as generics adapt to different data types.

**Good example:**

```java
// GOOD: Generic types adapt to different contexts
public class Repository<T extends Entity> {
    private final Class<T> entityClass;
    private final EntityManager entityManager;

    public Repository(Class<T> entityClass, EntityManager entityManager) {
        this.entityClass = entityClass;
        this.entityManager = entityManager;
    }

    public Optional<T> findById(Long id) {
        T entity = entityManager.find(entityClass, id);
        return Optional.ofNullable(entity);
    }

    public List<T> findAll() {
        CriteriaQuery<T> query = entityManager.getCriteriaBuilder()
                                              .createQuery(entityClass);
        query.select(query.from(entityClass));
        return entityManager.createQuery(query).getResultList();
    }

    public T save(T entity) {
        if (entity.getId() == null) {
            entityManager.persist(entity);
            return entity;
        } else {
            return entityManager.merge(entity);
        }
    }

    public void delete(T entity) {
        entityManager.remove(entity);
    }
}

// Usage for different entity types with full type safety
Repository<Customer> customerRepo = new Repository<>(Customer.class, em);
Repository<Product> productRepo = new Repository<>(Product.class, em);

// Type-safe operations
Optional<Customer> customer = customerRepo.findById(1L);
List<Product> products = productRepo.findAll();
```

**Bad example:**

```java
// AVOID: Multiple similar classes with duplicated logic
public class CustomerRepository {
    private final EntityManager entityManager;

    public CustomerRepository(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    public Optional<Customer> findById(Long id) {
        Customer customer = entityManager.find(Customer.class, id);
        return Optional.ofNullable(customer);
    }

    public List<Customer> findAll() {
        // Duplicated logic
        CriteriaQuery<Customer> query = entityManager.getCriteriaBuilder()
                                                    .createQuery(Customer.class);
        query.select(query.from(Customer.class));
        return entityManager.createQuery(query).getResultList();
    }

    public Customer save(Customer customer) {
        // Duplicated logic
        if (customer.getId() == null) {
            entityManager.persist(customer);
            return customer;
        } else {
            return entityManager.merge(customer);
        }
    }
}

public class ProductRepository {
    // Exact same code but for Product - massive duplication!
    private final EntityManager entityManager;

    public ProductRepository(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    public Optional<Product> findById(Long id) {
        Product product = entityManager.find(Product.class, id);
        return Optional.ofNullable(product);
    }

    // ... more duplicated methods
}
```

## Rule 5: Use BigDecimal for Precision-Sensitive Calculations

Title: Ensure Accuracy in Financial and Mathematical Operations
Description: This rule emphasizes using `java.math.BigDecimal` for calculations requiring high precision, especially with monetary values or any domain where rounding errors from binary floating-point arithmetic (like `float` or `double`) are unacceptable. Use consistent rounding modes and scale for predictable results.

**Good example:**

```java
// GOOD: Using BigDecimal for financial calculations
import java.math.BigDecimal;
import java.math.RoundingMode;

public class FinancialCalculator {
    private static final int CURRENCY_SCALE = 2;
    private static final RoundingMode ROUNDING_MODE = RoundingMode.HALF_UP;

    public static BigDecimal calculateTotalPrice(BigDecimal itemPrice, BigDecimal taxRate, int quantity) {
        validateInputs(itemPrice, taxRate, quantity);

        BigDecimal quantityDecimal = new BigDecimal(quantity);
        BigDecimal subtotal = itemPrice.multiply(quantityDecimal);
        BigDecimal taxAmount = subtotal.multiply(taxRate)
                                      .setScale(CURRENCY_SCALE, ROUNDING_MODE);

        return subtotal.add(taxAmount).setScale(CURRENCY_SCALE, ROUNDING_MODE);
    }

    public static BigDecimal calculateMonthlyPayment(BigDecimal principal,
                                                   BigDecimal annualRate,
                                                   int monthsTotal) {
        validateInputs(principal, annualRate, monthsTotal);

        if (annualRate.compareTo(BigDecimal.ZERO) == 0) {
            return principal.divide(new BigDecimal(monthsTotal), CURRENCY_SCALE, ROUNDING_MODE);
        }

        BigDecimal monthlyRate = annualRate.divide(new BigDecimal("12"), 10, ROUNDING_MODE);
        BigDecimal onePlusRate = BigDecimal.ONE.add(monthlyRate);
        BigDecimal powResult = onePlusRate.pow(monthsTotal);

        BigDecimal numerator = principal.multiply(monthlyRate).multiply(powResult);
        BigDecimal denominator = powResult.subtract(BigDecimal.ONE);

        return numerator.divide(denominator, CURRENCY_SCALE, ROUNDING_MODE);
    }

    private static void validateInputs(BigDecimal amount, BigDecimal rate, int months) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Amount must be non-negative");
        }
        if (rate == null || rate.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Rate must be non-negative");
        }
        if (months <= 0) {
            throw new IllegalArgumentException("Months must be positive");
        }
    }
}
```

**Bad example:**

```java
// AVOID: Using double for financial calculations - precision issues
public class InaccurateFinancialCalculator {
    public static double calculateTotalPrice(double itemPrice, double taxRate, int quantity) {
        if (itemPrice < 0 || taxRate < 0 || quantity <= 0) {
            throw new IllegalArgumentException("Invalid inputs");
        }

        double subtotal = itemPrice * quantity;
        double taxAmount = subtotal * taxRate;

        // Precision issues! 0.1 + 0.2 != 0.3 in floating point
        return subtotal + taxAmount;
    }

    public static double calculateMonthlyPayment(double principal, double annualRate, int months) {
        if (principal < 0 || annualRate < 0 || months <= 0) {
            throw new IllegalArgumentException("Invalid inputs");
        }

        if (annualRate == 0) {
            return principal / months;
        }

        double monthlyRate = annualRate / 12;
        double factor = Math.pow(1 + monthlyRate, months);

        // More precision issues with floating point arithmetic
        return (principal * monthlyRate * factor) / (factor - 1);
    }

    public static void main(String[] args) {
        // This will demonstrate the precision problem
        double result1 = calculateTotalPrice(19.99, 0.075, 3);
        double result2 = calculateTotalPrice(29.99, 0.08, 2);

        System.out.println("Result 1: " + result1); // May show unexpected decimals
        System.out.println("Result 2: " + result2); // May show unexpected decimals

        // Rounding manually is error-prone and inconsistent
        System.out.println("Rounded 1: " + Math.round(result1 * 100.0) / 100.0);
        System.out.println("Rounded 2: " + Math.round(result2 * 100.0) / 100.0);
    }
}
```
