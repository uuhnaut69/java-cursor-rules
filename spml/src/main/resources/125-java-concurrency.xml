<?xml version="1.0" encoding="UTF-8"?>
<system-prompt xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xsi:noNamespaceSchemaLocation="spml.xsd"
               id="125-java-concurrency" version="1.0">
    <metadata>
        <description>Java rules for Concurrency objects</description>
        <globs>*.java</globs>
        <always-apply>false</always-apply>
        <tags>
            <tag>java</tag>
            <tag>concurrency</tag>
            <tag>threads</tag>
            <tag>executors</tag>
            <tag>futures</tag>
            <tag>synchronization</tag>
            <tag>performance</tag>
        </tags>
        <version>1.0.0</version>
    </metadata>

    <header>
        <title>Java rules for Concurrency objects</title>
    </header>

    <system-characterization>
        <role-definition>You are a Senior software engineer with extensive experience in Java software development</role-definition>
    </system-characterization>

    <description>
        Effective Java concurrency relies on understanding thread safety fundamentals, using `java.util.concurrent` utilities, and managing thread pools with `ExecutorService`. Key practices include implementing concurrent design patterns like Producer-Consumer, leveraging `CompletableFuture` for asynchronous tasks, and ensuring thread safety through immutability and safe publication. Performance aspects like lock contention and memory consistency must be considered. Thorough testing, including stress tests and thread dump analysis, is crucial. Modern Java offers virtual threads for enhanced scalability, structured concurrency for simplified task management, and scoped values for safer thread-shared data as alternatives to thread-locals.
    </description>

    <toc auto-generate="true"/>

    <content-sections>
        <rule-section number="1" id="thread-safety-fundamentals">
            <rule-header>
                <rule-title>Thread Safety Fundamentals</rule-title>
                <rule-subtitle>Master Core Thread Safety Concepts</rule-subtitle>
            </rule-header>
            <rule-description>
                Understand and correctly apply core concepts such as synchronization, atomic operations, thread-safe collections, immutability, and the Java Memory Model to ensure data integrity and prevent race conditions or deadlocks.
            </rule-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// GOOD: Proper thread safety using concurrent collections and atomics
import java.util.Map;
import java.util.Queue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ThreadSafeCounter {
    // Preferred concurrent collections
    private final Map<String, String> concurrentMap = new ConcurrentHashMap<>();
    private final Queue<String> taskQueue = new ConcurrentLinkedQueue<>();
    private final BlockingQueue<String> eventQueue = new LinkedBlockingQueue<>();

    // Atomic variables for lock-free operations
    private final AtomicInteger counter = new AtomicInteger(0);
    private final AtomicReference<String> status = new AtomicReference<>("INIT");

    // Thread-local storage
    private static final ThreadLocal<String> userContext =
        ThreadLocal.withInitial(() -> "default");

    // Using ReentrantLock for complex synchronization
    private final ReentrantLock lock = new ReentrantLock();
    private int sharedResource = 0;

    public void incrementCounter() {
        // Atomic operation - thread-safe without locks
        int newValue = counter.incrementAndGet();
        concurrentMap.put("lastCount", String.valueOf(newValue));
    }

    public void updateSharedResource(int delta) {
        lock.lock();
        try {
            sharedResource += delta;
            System.out.println("Updated resource: " + sharedResource);
        } finally {
            lock.unlock(); // Always unlock in finally block
        }
    }

    // Using ReadWriteLock for better performance with frequent reads
    private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
    private String sharedData = "Initial Data";

    public String readData() {
        rwLock.readLock().lock();
        try {
            return sharedData;
        } finally {
            rwLock.readLock().unlock();
        }
    }

    public void writeData(String data) {
        rwLock.writeLock().lock();
        try {
            sharedData = data;
        } finally {
            rwLock.writeLock().unlock();
        }
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// AVOID: Poor thread safety practices
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class UnsafeCounter {
    // BAD: Using non-thread-safe collections
    private Map<String, String> unsafeMap = new HashMap<>();
    private List<String> unsafeList = new ArrayList<>();

    // BAD: Using plain int without synchronization
    private int counter = 0;
    private String status = "INIT";

    public void incrementCounter() {
        // RACE CONDITION: Multiple threads can read same value
        counter++; // Not atomic - can lose updates
        unsafeMap.put("lastCount", String.valueOf(counter)); // Can corrupt map
    }

    // BAD: Inconsistent synchronization
    public synchronized void updateCounter(int value) {
        counter = value; // Synchronized
    }

    public int getCounter() {
        return counter; // NOT synchronized - can read stale value
    }

    // BAD: Synchronizing on mutable object
    private String lockObject = "lock";

    public void badSynchronization() {
        synchronized (lockObject) { // WRONG: string can be changed
            // Critical section
        }
        lockObject = "newLock"; // Now synchronization is broken!
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </rule-section>

        <rule-section number="2" id="thread-pool-management">
            <rule-header>
                <rule-title>Thread Pool Management</rule-title>
                <rule-subtitle>Manage Thread Pools Effectively with ExecutorService</rule-subtitle>
            </rule-header>
            <rule-description>
                Utilize ExecutorService for robust thread management. Choose appropriate thread pool implementations, configure them properly, and implement graceful shutdown procedures.
            </rule-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// GOOD: Proper thread pool management
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

public class ThreadPoolManager {
    private final ExecutorService fixedPool;
    private final ScheduledExecutorService scheduler;
    private final ThreadPoolExecutor customPool;

    public ThreadPoolManager() {
        // Fixed thread pool with named threads
        this.fixedPool = Executors.newFixedThreadPool(
            Runtime.getRuntime().availableProcessors(),
            new CustomThreadFactory("worker")
        );

        // Scheduled thread pool for periodic tasks
        this.scheduler = Executors.newScheduledThreadPool(
            1,
            new CustomThreadFactory("scheduler")
        );

        // Custom thread pool with fine-grained control
        this.customPool = new ThreadPoolExecutor(
            2,                                    // core pool size
            4,                                    // maximum pool size
            60L,                                  // keep alive time
            TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(100),       // bounded queue
            new CustomThreadFactory("custom"),
            new ThreadPoolExecutor.CallerRunsPolicy() // rejection policy
        );
    }

    public void submitTask(Runnable task) {
        fixedPool.submit(task);
    }

    public void schedulePeriodicTask(Runnable task, long period) {
        scheduler.scheduleAtFixedRate(task, 0, period, TimeUnit.SECONDS);
    }

    public void shutdown() {
        shutdownExecutorService(fixedPool, "FixedPool");
        shutdownExecutorService(scheduler, "Scheduler");
        shutdownExecutorService(customPool, "CustomPool");
    }

    private void shutdownExecutorService(ExecutorService executor, String name) {
        executor.shutdown(); // Disable new tasks
        try {
            // Wait for existing tasks to terminate
            if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                executor.shutdownNow(); // Cancel currently executing tasks

                // Wait for tasks to respond to being cancelled
                if (!executor.awaitTermination(60, TimeUnit.SECONDS)) {
                    System.err.println("Pool " + name + " did not terminate");
                }
            }
        } catch (InterruptedException ie) {
            executor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }

    // Custom thread factory for better thread naming and error handling
    private static class CustomThreadFactory implements ThreadFactory {
        private final AtomicInteger threadNumber = new AtomicInteger(1);
        private final String namePrefix;

        CustomThreadFactory(String namePrefix) {
            this.namePrefix = namePrefix + "-thread-";
        }

        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r, namePrefix + threadNumber.getAndIncrement());
            t.setDaemon(false);
            t.setUncaughtExceptionHandler((thread, ex) -> {
                System.err.println("Thread " + thread.getName() + " threw exception: " + ex);
            });
            return t;
        }
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// AVOID: Poor thread pool management
import java.util.concurrent.Executors;
import java.util.concurrent.ExecutorService;

public class PoorThreadPoolManager {
    // BAD: Unbounded thread pools can cause resource exhaustion
    private ExecutorService cachedPool = Executors.newCachedThreadPool();

    // BAD: Single thread with unbounded queue
    private ExecutorService singleThread = Executors.newSingleThreadExecutor();

    public void submitTask(Runnable task) {
        // BAD: No error handling or resource management
        cachedPool.submit(task);
    }

    public void submitManyTasks() {
        for (int i = 0; i < 10000; i++) {
            // BAD: Can overwhelm the system
            cachedPool.submit(() -> {
                try {
                    Thread.sleep(10000); // Long-running task
                } catch (InterruptedException e) {
                    // BAD: Ignoring interruption
                }
            });
        }
    }

    // BAD: No proper shutdown
    public void shutdown() {
        cachedPool.shutdown(); // What if tasks don't finish?
        singleThread.shutdown();
        // No waiting for termination
        // No handling of interrupted exception
        // No forced shutdown if graceful shutdown fails
    }

    // BAD: Creating new thread for each task
    public void executeTask(Runnable task) {
        new Thread(task).start(); // Expensive and uncontrolled
    }

    // BAD: No thread naming or error handling
    // Default thread names are not descriptive
    // Uncaught exceptions terminate threads silently
}]]></code-block>
                </bad-example>
            </code-examples>
        </rule-section>

        <rule-section number="3" id="concurrent-design-patterns">
            <rule-header>
                <rule-title>Concurrent Design Patterns</rule-title>
                <rule-subtitle>Implement Producer-Consumer and Publish-Subscribe</rule-subtitle>
            </rule-header>
            <rule-description>
                Leverage established patterns like Producer-Consumer and Publish-Subscribe to structure concurrent applications effectively, promoting decoupling, scalability, and maintainability.
            </rule-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// GOOD: Producer-Consumer pattern with BlockingQueue
import java.util.concurrent.*;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

// Producer-Consumer implementation
public class ProducerConsumerExample {
    private final BlockingQueue<Task> queue = new LinkedBlockingQueue<>(100);
    private final ExecutorService executor = Executors.newFixedThreadPool(4);
    private volatile boolean running = true;

    public void startProcessing() {
        // Start multiple consumers
        for (int i = 0; i < 2; i++) {
            executor.submit(this::consumer);
        }
    }

    public void produce(Task task) throws InterruptedException {
        if (running) {
            queue.put(task); // Blocks if queue is full
        }
    }

    private void consumer() {
        while (running || !queue.isEmpty()) {
            try {
                Task task = queue.poll(1, TimeUnit.SECONDS);
                if (task != null) {
                    processTask(task);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                break;
            }
        }
    }

    private void processTask(Task task) {
        System.out.println("Processing: " + task + " on " + Thread.currentThread().getName());
        // Simulate work
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    public void shutdown() {
        running = false;
        executor.shutdown();
    }

    private static class Task {
        private final String data;
        public Task(String data) { this.data = data; }
        @Override public String toString() { return "Task(" + data + ")"; }
    }
}

// Publish-Subscribe implementation
public class EventBus {
    private final ConcurrentHashMap<String, Set<EventListener>> listeners = new ConcurrentHashMap<>();
    private final ExecutorService notificationExecutor = ForkJoinPool.commonPool();

    public void subscribe(String topic, EventListener listener) {
        listeners.computeIfAbsent(topic, k -> ConcurrentHashMap.newKeySet())
                 .add(listener);
    }

    public void unsubscribe(String topic, EventListener listener) {
        Set<EventListener> topicListeners = listeners.get(topic);
        if (topicListeners != null) {
            topicListeners.remove(listener);
        }
    }

    public void publish(String topic, Event event) {
        Set<EventListener> topicListeners = listeners.get(topic);
        if (topicListeners != null && !topicListeners.isEmpty()) {
            // Notify listeners asynchronously
            topicListeners.forEach(listener ->
                notificationExecutor.submit(() -> {
                    try {
                        listener.onEvent(event);
                    } catch (Exception e) {
                        System.err.println("Error notifying listener: " + e.getMessage());
                    }
                })
            );
        }
    }

    private static class Event {
        private final String data;
        public Event(String data) { this.data = data; }
        @Override public String toString() { return "Event(" + data + ")"; }
    }

    @FunctionalInterface
    private interface EventListener {
        void onEvent(Event event);
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// AVOID: Poor concurrent pattern implementation
import java.util.*;

public class BadProducerConsumer {
    // BAD: Using non-thread-safe collection
    private List<String> tasks = new ArrayList<>();
    private boolean running = true;

    public void produce(String task) {
        // RACE CONDITION: Multiple producers can corrupt the list
        synchronized (this) {
            tasks.add(task);
            notify(); // BAD: Should use notifyAll()
        }
    }

    public void consume() {
        while (running) {
            String task = null;
            synchronized (this) {
                while (tasks.isEmpty() && running) {
                    try {
                        wait(); // BAD: Can miss notifications
                    } catch (InterruptedException e) {
                        // BAD: Not handling interruption properly
                        return;
                    }
                }
                if (!tasks.isEmpty()) {
                    task = tasks.remove(0); // BAD: Inefficient removal from front
                }
            }

            if (task != null) {
                // BAD: Processing inside synchronized block would be even worse
                processTask(task);
            }
        }
    }

    // BAD: No proper shutdown mechanism
    public void stop() {
        running = false; // Consumers might not wake up
    }
}

// BAD: Synchronous event handling
public class BadEventBus {
    private Map<String, List<EventListener>> listeners = new HashMap<>();

    public void subscribe(String topic, EventListener listener) {
        // BAD: Not thread-safe
        listeners.computeIfAbsent(topic, k -> new ArrayList<>()).add(listener);
    }

    public void publish(String topic, String event) {
        List<EventListener> topicListeners = listeners.get(topic);
        if (topicListeners != null) {
            // BAD: Synchronous notification blocks publisher
            for (EventListener listener : topicListeners) {
                try {
                    listener.onEvent(event);
                } catch (Exception e) {
                    // BAD: One failing listener affects others
                    throw new RuntimeException("Event handling failed", e);
                }
            }
        }
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </rule-section>

        <rule-section number="4" id="completable-future">
            <rule-header>
                <rule-title>Asynchronous Programming with CompletableFuture</rule-title>
                <rule-subtitle>Compose Non-blocking Asynchronous Operations</rule-subtitle>
            </rule-header>
            <rule-description>
                Employ CompletableFuture to compose and manage asynchronous computations in a non-blocking way. Chain dependent tasks, combine results from multiple futures, and handle exceptions gracefully.
            </rule-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// GOOD: CompletableFuture for asynchronous processing
import java.util.concurrent.*;
import java.util.List;
import java.util.stream.Collectors;

public class AsyncService {
    private final ExecutorService customExecutor = Executors.newFixedThreadPool(4);

    public CompletableFuture<String> processDataAsync(String input) {
        return CompletableFuture
            .supplyAsync(() -> validateInput(input), customExecutor)
            .thenApplyAsync(this::transformData, customExecutor)
            .thenApply(this::formatResult)
            .exceptionally(this::handleError)
            .whenComplete((result, ex) -> {
                if (ex != null) {
                    System.err.println("Processing failed for: " + input);
                } else {
                    System.out.println("Successfully processed: " + input);
                }
            });
    }

    public CompletableFuture<List<String>> processMultipleAsync(List<String> inputs) {
        List<CompletableFuture<String>> futures = inputs.stream()
            .map(this::processDataAsync)
            .collect(Collectors.toList());

        return CompletableFuture.allOf(futures.toArray(new CompletableFuture[0]))
            .thenApply(v -> futures.stream()
                .map(CompletableFuture::join)
                .collect(Collectors.toList()))
            .exceptionally(ex -> {
                System.err.println("Batch processing failed: " + ex.getMessage());
                return List.of("ERROR");
            });
    }

    public CompletableFuture<String> combineResults(String input1, String input2) {
        CompletableFuture<String> future1 = processDataAsync(input1);
        CompletableFuture<String> future2 = processDataAsync(input2);

        return future1.thenCombine(future2, (result1, result2) ->
            "Combined: " + result1 + " + " + result2);
    }

    public CompletableFuture<String> getFirstSuccessful(List<String> inputs) {
        CompletableFuture<String>[] futures = inputs.stream()
            .map(this::processDataAsync)
            .toArray(CompletableFuture[]::new);

        return CompletableFuture.anyOf(futures)
            .thenApply(result -> (String) result);
    }

    private String validateInput(String input) {
        if (input == null || input.trim().isEmpty()) {
            throw new IllegalArgumentException("Input cannot be null or empty");
        }
        // Simulate validation work
        try { Thread.sleep(100); } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
        return input.trim();
    }

    private String transformData(String input) {
        // Simulate transformation work
        try { Thread.sleep(200); } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            throw new RuntimeException(e);
        }
        return "transformed_" + input;
    }

    private String formatResult(String input) {
        return "[" + input + "]";
    }

    private String handleError(Throwable throwable) {
        System.err.println("Error occurred: " + throwable.getMessage());
        return "ERROR: " + throwable.getClass().getSimpleName();
    }

    public void shutdown() {
        customExecutor.shutdown();
        try {
            if (!customExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                customExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            customExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// AVOID: Blocking operations and poor error handling
import java.util.concurrent.*;
import java.util.List;
import java.util.ArrayList;

public class BadAsyncService {

    public String processDataBlocking(String input) {
        // BAD: Using CompletableFuture but blocking immediately
        CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
            return processInput(input);
        });

        try {
            return future.get(); // BLOCKING! Defeats the purpose
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    public List<String> processMultipleBlocking(List<String> inputs) {
        List<String> results = new ArrayList<>();

        // BAD: Sequential processing instead of parallel
        for (String input : inputs) {
            CompletableFuture<String> future = CompletableFuture.supplyAsync(() ->
                processInput(input));

            try {
                results.add(future.get()); // BLOCKING in loop
            } catch (Exception e) {
                // BAD: One failure stops everything
                throw new RuntimeException("Processing failed", e);
            }
        }

        return results;
    }

    public CompletableFuture<String> badErrorHandling(String input) {
        return CompletableFuture.supplyAsync(() -> {
            if ("fail".equals(input)) {
                throw new RuntimeException("Simulated failure");
            }
            return processInput(input);
        });
        // BAD: No error handling - exceptions will propagate
    }

    public void badChaining(String input) {
        // BAD: Not chaining properly, creating nested futures
        CompletableFuture<CompletableFuture<String>> nestedFuture =
            CompletableFuture.supplyAsync(() -> {
                return CompletableFuture.supplyAsync(() -> {
                    return processInput(input);
                });
            });

        // Now you have a nested CompletableFuture - hard to work with
    }

    // BAD: Resource leak - no executor shutdown
    private final ExecutorService executor = Executors.newFixedThreadPool(10);

    public CompletableFuture<String> processWithLeakedExecutor(String input) {
        return CompletableFuture.supplyAsync(() -> processInput(input), executor);
        // BAD: Executor never gets shut down
    }

    private String processInput(String input) {
        try {
            Thread.sleep(1000); // Simulate work
        } catch (InterruptedException e) {
            // BAD: Not handling interruption properly
        }
        return "processed_" + input;
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </rule-section>

        <rule-section number="5" id="virtual-threads">
            <rule-header>
                <rule-title>Embrace Virtual Threads for Enhanced Scalability</rule-title>
                <rule-subtitle>Use Virtual Threads for I/O-bound Tasks</rule-subtitle>
            </rule-header>
            <rule-description>
                Leverage virtual threads (Project Loom) for I/O-bound tasks to dramatically increase scalability with minimal resource overhead. Avoid pooling virtual threads and use structured concurrency where appropriate.
            </rule-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// GOOD: Using virtual threads for scalable I/O operations
import java.util.concurrent.*;
import java.util.List;
import java.util.stream.IntStream;

public class VirtualThreadExample {

    // Use virtual thread executor for I/O-bound tasks
    private final ExecutorService virtualExecutor = Executors.newVirtualThreadPerTaskExecutor();

    public void handleManyIORequests() {
        List<Future<String>> futures = IntStream.range(0, 10000)
            .mapToObj(i -> virtualExecutor.submit(() -> performIOOperation("task-" + i)))
            .toList();

        // Collect results
        futures.forEach(future -> {
            try {
                String result = future.get();
                System.out.println("Completed: " + result);
            } catch (Exception e) {
                System.err.println("Task failed: " + e.getMessage());
            }
        });
    }

    // Virtual threads are perfect for blocking I/O operations
    private String performIOOperation(String taskId) {
        try {
            // Simulate I/O operation (database call, web request, etc.)
            Thread.sleep(1000); // This would block a platform thread
            return "Result for " + taskId;
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return "Interrupted: " + taskId;
        }
    }

    // Using scoped values with virtual threads (Java 20+)
    private static final ScopedValue<String> USER_ID = ScopedValue.newInstance();

    public void processWithScopedValue(String userId, List<String> tasks) {
        // Run with scoped value
        ScopedValue.where(USER_ID, userId)
            .run(() -> {
                tasks.parallelStream().forEach(task -> {
                    virtualExecutor.submit(() -> {
                        // Access scoped value safely
                        String currentUserId = USER_ID.get();
                        performTaskForUser(currentUserId, task);
                    });
                });
            });
    }

    private void performTaskForUser(String userId, String task) {
        System.out.println("Processing task " + task + " for user " + userId +
                          " on thread " + Thread.currentThread());
    }

    // Structured concurrency for managing related tasks
    public String fetchUserDataWithStructuredConcurrency(String userId) throws Exception {
        try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {

            Future<String> profile = scope.fork(() -> fetchUserProfile(userId));
            Future<String> preferences = scope.fork(() -> fetchUserPreferences(userId));
            Future<String> history = scope.fork(() -> fetchUserHistory(userId));

            scope.join();           // Wait for all tasks
            scope.throwIfFailed();  // Propagate any failures

            // All tasks completed successfully
            return combineUserData(profile.resultNow(),
                                 preferences.resultNow(),
                                 history.resultNow());
        }
    }

    private String fetchUserProfile(String userId) {
        // Simulate I/O operation
        try { Thread.sleep(100); } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return "Profile for " + userId;
    }

    private String fetchUserPreferences(String userId) {
        try { Thread.sleep(150); } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return "Preferences for " + userId;
    }

    private String fetchUserHistory(String userId) {
        try { Thread.sleep(200); } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        return "History for " + userId;
    }

    private String combineUserData(String profile, String preferences, String history) {
        return String.format("User data: %s, %s, %s", profile, preferences, history);
    }

    public void shutdown() {
        virtualExecutor.shutdown();
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// AVOID: Misusing virtual threads
import java.util.concurrent.*;

public class BadVirtualThreadUsage {

    // BAD: Creating thread pools for virtual threads
    private final ExecutorService virtualPool = Executors.newFixedThreadPool(100,
        Thread.ofVirtual().factory()); // Don't pool virtual threads!

    // BAD: Using virtual threads for CPU-intensive tasks
    public void performCPUIntensiveWork() {
        ExecutorService virtualExecutor = Executors.newVirtualThreadPerTaskExecutor();

        for (int i = 0; i < 1000; i++) {
            virtualExecutor.submit(() -> {
                // BAD: Virtual threads are not suitable for CPU-bound work
                double result = 0;
                for (int j = 0; j < 1_000_000; j++) {
                    result += Math.sqrt(j) * Math.sin(j);
                }
                return result;
            });
        }
    }

    // BAD: Using platform thread patterns with virtual threads
    public void badResourceManagement() {
        // Creating virtual threads manually instead of using executor
        for (int i = 0; i < 10000; i++) {
            Thread.ofVirtual().start(() -> {
                performIOOperation();
                // BAD: No proper cleanup or error handling
            });
        }
    }

    // BAD: Blocking operations that shouldn't be used with virtual threads
    public void problematicBlocking() {
        ExecutorService virtualExecutor = Executors.newVirtualThreadPerTaskExecutor();

        virtualExecutor.submit(() -> {
            try {
                synchronized (this) { // BAD: Synchronized blocks can pin virtual threads
                    Thread.sleep(1000); // This pins the virtual thread to platform thread
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
    }

    // BAD: Using ThreadLocal instead of ScopedValue
    private static final ThreadLocal<String> USER_CONTEXT = new ThreadLocal<>();

    public void badContextPropagation() {
        USER_CONTEXT.set("user123");

        ExecutorService virtualExecutor = Executors.newVirtualThreadPerTaskExecutor();
        virtualExecutor.submit(() -> {
            // BAD: ThreadLocal values don't propagate to virtual threads properly
            String userId = USER_CONTEXT.get(); // Likely null
            performTaskForUser(userId);
        });
    }

    private void performIOOperation() {
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }

    private void performTaskForUser(String userId) {
        System.out.println("Processing for user: " + userId);
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </rule-section>
    </content-sections>
</system-prompt>
