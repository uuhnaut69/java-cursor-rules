<?xml version="1.0" encoding="UTF-8"?>
<prompt xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:xi="http://www.w3.org/2001/XInclude"
        xsi:noNamespaceSchemaLocation="pml.xsd"
        id="123-java-general-guidelines" version="1.0">

    <metadata>
        <cursor-ai>
            <description></description>
            <globs></globs>
            <always-apply>false</always-apply>
        </cursor-ai>
        <tags>
            <tag>java</tag>
            <tag>guidelines</tag>
            <tag>naming</tag>
            <tag>formatting</tag>
            <tag>documentation</tag>
            <tag>exceptions</tag>
            <tag>best-practices</tag>
        </tags>
        <version>0.8.0</version>
        <title>Java General Guidelines</title>
    </metadata>

    <role>You are a Senior software engineer with extensive experience in Java software development</role>

    <goal>
        This document outlines general Java coding guidelines covering fundamental aspects such as naming conventions for packages, classes, methods, variables, and constants; code formatting rules including indentation, line length, brace style, and whitespace usage; standards for organizing import statements; best practices for Javadoc documentation; and comprehensive error and exception handling with a strong focus on security, including avoiding sensitive information exposure, catching specific exceptions, and secure resource management.

        <xi:include href="fragments/system-prompt-behaviour-consultative-interaction-template.md" parse="text"/>
        ### Implementing These Principles

        These guidelines are built upon the following core principles:

        1. **Clarity and Consistency in Naming**: Adhere to standard Java naming conventions for all code elements (packages, classes, methods, variables, constants). This promotes code that is intuitive, predictable, and easier for developers to understand and navigate.
        2. **Readability through Formatting**: Consistently apply formatting rules for indentation, line length, brace style, and whitespace. Well-formatted code is significantly easier to read, debug, and maintain.
        3. **Organized Import Statements**: Structure import statements logically by grouping related packages and alphabetizing within those groups. Avoid wildcard imports to ensure clarity about class origins and prevent namespace conflicts.
        4. **Effective Documentation**: Strive for self-documenting code. For public APIs, complex algorithms, non-obvious business logic, or any part of the code that isn't immediately clear, provide comprehensive Javadoc. Good documentation aids understanding, usage, and maintenance.
        5. **Robust and Secure Error Handling**: Implement thorough error and exception handling with a strong focus on security. This includes using specific exceptions, managing resources diligently (preferably with try-with-resources), preventing the leakage of sensitive information in logs or error messages, and never "swallowing" exceptions without proper handling or justification. Resilient and secure applications depend on robust error management.
    </goal>

    <examples>
        <toc auto-generate="true"/>

        <example number="1" id="naming-conventions">
            <example-header>
                <example-title>Naming Conventions</example-title>
                <example-subtitle>Follow Standard Java Naming Patterns</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Adhere to standard Java naming conventions for all code elements to promote intuitive, predictable, and easier to understand code navigation.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// GOOD: Proper naming conventions
package com.example.project.module; // Lowercase, reverse domain notation

public class UserProfileService { // PascalCase for classes
    public static final int MAX_LOGIN_ATTEMPTS = 3; // ALL_CAPS_SNAKE_CASE for constants

    private final UserRepository userRepository; // camelCase for variables

    public UserDTO getUserByUsername(String username) { // camelCase for methods
        // ... implementation
    }

    private boolean isValid(String input) { // Boolean methods with 'is', 'has', 'can' prefix
        return input != null && !input.trim().isEmpty();
    }
}

// Generic type parameters
public class Repository<T extends Entity> { // Single uppercase letter
    // ... implementation
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// AVOID: Poor naming conventions
package My_App_Services; // Uses underscores and wrong case

public class userprofilesvc { // Not PascalCase
    public static final int defaultpagesize = 20; // Not ALL_CAPS_SNAKE_CASE

    private UserRepository mUserRepository; // Hungarian notation (avoid)

    public UserDTO GetUser(String Username) { // Wrong case for method and parameter
        // ... implementation
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="2" id="formatting">
            <example-header>
                <example-title>Formatting</example-title>
                <example-subtitle>Apply Consistent Code Formatting</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Consistently apply formatting rules for indentation, line length, brace style, and whitespace to improve code readability and maintainability.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// GOOD: Proper formatting
public class FormattingExample {
    private static final int MAX_RETRY_COUNT = 3; // Proper spacing around operators

    public void processData(String input) {
        if (input == null || input.isEmpty()) { // K&R brace style
            logger.warn("Input is null or empty");
            return;
        }

        for (int i = 0; i < MAX_RETRY_COUNT; i++) { // Spaces after keywords and around operators
            try {
                performOperation(input);
                break;
            } catch (TemporaryException e) {
                logger.debug("Retry attempt {}: {}", i + 1, e.getMessage());
            }
        }
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// AVOID: Poor formatting
public class BadFormattingExample{
    private static final int MAX_RETRY_COUNT=3;// No spaces

    public void processData(String input){
        if(input==null||input.isEmpty())// No spaces, missing braces
          logger.warn("Input is null or empty");

        for(int i=0;i<MAX_RETRY_COUNT;i++){
          try{
            performOperation(input);
            break;
          }catch(TemporaryException e){// catch on same line
            logger.debug("Retry attempt "+i+": "+e.getMessage());
          }
        }
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="3" id="import-statements">
            <example-header>
                <example-title>Import Statements</example-title>
                <example-subtitle>Organize Imports Systematically</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Structure import statements logically by grouping related packages and alphabetizing within groups. Avoid wildcard imports to ensure clarity about class origins.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// GOOD: Organized imports
package com.example.myapp.services;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

import jakarta.persistence.Entity;
import jakarta.persistence.Id;

import org.springframework.stereotype.Service;

import static com.example.myapp.utils.ValidationConstants.MAX_NAME_LENGTH;

import com.example.myapp.dto.UserDTO;
import com.example.myapp.exceptions.InvalidUserDataException;

@Service
public class UserService {
    // ... implementation
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// AVOID: Disorganized imports
package com.example.myapp.services;

import java.util.*; // Wildcard import
import com.example.myapp.dto.UserDTO;
import java.util.Objects; // Mixed order
import com.example.myapp.exceptions.InvalidUserDataException;
import static com.example.myapp.utils.ValidationConstants.MAX_NAME_LENGTH; // Static import not grouped
import org.springframework.stereotype.Service;

@Service
public class UserService {
    // ... implementation
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="4" id="documentation-standards">
            <example-header>
                <example-title>Documentation Standards</example-title>
                <example-subtitle>Maintain Clear Documentation</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Write self-documenting code and provide comprehensive Javadoc for public APIs, complex algorithms, and non-obvious business logic with required elements like @param, @return, @throws.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// GOOD: Comprehensive documentation
/**
 * Utility class for string manipulations and validation.
 *
 * @since 1.0
 */
public class StringUtil {

    /**
     * Checks if a string is null or empty.
     *
     * @param str The string to check, may be null
     * @return {@code true} if the string is null or empty, {@code false} otherwise
     * @throws IllegalArgumentException if the input string is "error" (for demo purposes)
     */
    public static boolean isNullOrEmpty(String str) throws IllegalArgumentException {
        if ("error".equals(str)) {
            throw new IllegalArgumentException("Input cannot be 'error'");
        }
        return str == null || str.isEmpty();
    }

    /**
     * Validates and sanitizes user input for safe processing.
     *
     * @param input The raw user input to validate
     * @return The sanitized input
     * @throws ValidationException if input fails validation rules
     */
    public static String sanitizeInput(String input) throws ValidationException {
        // Implementation with clear business logic comments
        if (input == null) {
            throw new ValidationException("Input cannot be null");
        }

        // Remove potentially dangerous characters
        String sanitized = input.replaceAll("[<>\"'&]", "");

        return sanitized.trim();
    }
}]]></code-block>
                </good-example>
                <bad-example>
                    <code-block language="java"><![CDATA[// AVOID: Poor or missing documentation
public class StringHelper {
    // No explanation of what it does or parameters
    public boolean check(String s) {
        return s == null || s.length() == 0;
    }

    // Unclear method name and no documentation
    public String fix(String s) {
        return s.replaceAll("[<>]", "");
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>

        <example number="5" id="comprehensive-error-handling">
            <example-header>
                <example-title>Comprehensive Error and Exception Handling</example-title>
                <example-subtitle>Implement Secure and Robust Error Management</example-subtitle>
            </example-header>
            <example-description>
                <![CDATA[
                Implement robust error handling using specific exceptions, managing them at appropriate levels while preventing information leakage and ensuring proper resource cleanup.
                ]]>
            </example-description>
            <code-examples>
                <good-example>
                    <code-block language="java"><![CDATA[// GOOD: Comprehensive error handling
public class SecureFileProcessor {
    private static final Logger logger = LoggerFactory.getLogger(SecureFileProcessor.class);

    /**
     * Reads file content safely with proper error handling.
     *
     * @param filePath The path to the file to read
     * @return The file content
     * @throws FileProcessingException if file cannot be processed
     */
    public String readFile(Path filePath) throws FileProcessingException {
        if (filePath == null) {
            throw new IllegalArgumentException("File path cannot be null");
        }

        StringBuilder content = new StringBuilder();

        // try-with-resources ensures proper resource cleanup
        try (BufferedReader reader = Files.newBufferedReader(filePath, StandardCharsets.UTF_8)) {
            String line;
            while ((line = reader.readLine()) != null) {
                content.append(line).append(System.lineSeparator());
            }
        } catch (NoSuchFileException e) {
            logger.warn("File not found: {}", filePath.getFileName());
            throw new FileProcessingException("Requested file not found", e);
        } catch (AccessDeniedException e) {
            logger.error("Access denied reading file: {}", filePath.getFileName());
            throw new FileProcessingException("Access denied", e);
        } catch (IOException e) {
            logger.error("IO error reading file: {}", filePath.getFileName(), e);
            throw new FileProcessingException("Failed to read file", e);
        }

        return content.toString();
    }
}]]></code-block>
                </good-example>
                <bad-example last-item="true">
                    <code-block language="java"><![CDATA[// AVOID: Poor error handling
public class UnsafeFileProcessor {

    public String readFile(String filePath) {
        BufferedReader reader = null;
        try {
            reader = new BufferedReader(new FileReader(filePath));
            // ... reading logic
        } catch (Exception e) {
            // Swallowing exception - bad practice!
            e.printStackTrace(); // Not using proper logging
            return ""; // Hiding the problem
        } finally {
            if (reader != null) {
                try {
                    reader.close();
                } catch (IOException e) {
                    // Another swallowed exception
                }
            }
        }
        return null;
    }
}]]></code-block>
                </bad-example>
            </code-examples>
        </example>
    </examples>

    <output-format>
        <output-format-list>
            <output-format-item>Apply the Java general guidelines to improve code quality and maintainability</output-format-item>
            <output-format-item>Follow naming conventions, formatting rules, and documentation standards</output-format-item>
            <output-format-item>Implement comprehensive error handling with security considerations</output-format-item>
        </output-format-list>
    </output-format>

    <safeguards>
        <safeguards-list>
            <safeguards-item>Verify code changes compile and pass tests: `mvn clean verify` or `./mvnw clean verify`</safeguards-item>
        </safeguards-list>
    </safeguards>
</prompt>
